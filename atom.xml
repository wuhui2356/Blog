<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>wuhui2356&#39;s Blog</title>
  
  
  <link href="https://blog.wuhui2356.top/atom.xml" rel="self"/>
  
  <link href="https://blog.wuhui2356.top/"/>
  <updated>2022-12-04T13:54:40.141Z</updated>
  <id>https://blog.wuhui2356.top/</id>
  
  <author>
    <name>wuhui2356</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>npm常用命令</title>
    <link href="https://blog.wuhui2356.top/2022/02/07/npm%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://blog.wuhui2356.top/2022/02/07/npm%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</id>
    <published>2022-02-07T04:20:11.000Z</published>
    <updated>2022-12-04T13:54:40.141Z</updated>
    
    <content type="html"><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p><code>NPM</code>是随同<code>NodeJS</code>一起安装的包管理工具，能解决<code>NodeJS</code>代码部署上的很多问题，本文主要对<code>NPM</code>的基本使用、依赖包的升级方法等进行简要的记录说明。</p><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><ul><li>依赖包安装： <code>npm install xxx</code></li><li>全局安装依赖包: <code>npm install -g xxxx</code></li><li>查看缓存路径:   <code>npm config get cache</code></li><li>修改缓存路径:  <code>npm config set cache /path/a/b</code></li><li>查看依赖包是否已经过期: <code>npm outdated</code></li><li>指定环境变量启动: <code>npx cross-env NODE_OPTIONS=&quot;--trace-warnings&quot; hexo s</code></li></ul><h1 id="依赖包升级"><a href="#依赖包升级" class="headerlink" title="依赖包升级"></a>依赖包升级</h1><ul><li>安装工具：  <code>npm install -g npm-check-updates</code></li><li>通过<code>ncu</code>工具再次检查是否有依赖包需要进行升级操作:  <code>ncu</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 这里的ncu为上文安装的npm-check-updates工具的简写</span><br><span class="line">$ ncu</span><br><span class="line"></span><br><span class="line">Checking F:\blog\package.json</span><br><span class="line">[====================] 24/24 100%</span><br><span class="line"></span><br><span class="line"> bufferutil            ^4.0.5  →   ^4.0.6</span><br><span class="line"> chokidar              ^3.5.2  →   ^3.5.3</span><br><span class="line"> hexo                  ^5.4.0  →   ^6.0.0</span><br><span class="line"> hexo-renderer-marked  ^4.1.0  →   ^5.0.0</span><br><span class="line"> hexo-server           ^2.0.0  →   ^3.0.0</span><br><span class="line"> hexo-theme-next       ^8.8.2  →   ^8.9.0</span><br><span class="line"> marked                ^4.0.6  →  ^4.0.12</span><br><span class="line"> utf-8-validate        ^5.0.7  →   ^5.0.8</span><br><span class="line"></span><br><span class="line">Run ncu -u to upgrade package.json</span><br></pre></td></tr></table></figure><ul><li>更新<code>package.json</code>文件中的依赖包:   <code>ncu -u</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ ncu -u</span><br><span class="line">Upgrading F:\blog\package.json</span><br><span class="line">[====================] 24/24 100%</span><br><span class="line"></span><br><span class="line"> bufferutil            ^4.0.5  →   ^4.0.6</span><br><span class="line"> chokidar              ^3.5.2  →   ^3.5.3</span><br><span class="line"> hexo                  ^5.4.0  →   ^6.0.0</span><br><span class="line"> hexo-renderer-marked  ^4.1.0  →   ^5.0.0</span><br><span class="line"> hexo-server           ^2.0.0  →   ^3.0.0</span><br><span class="line"> hexo-theme-next       ^8.8.2  →   ^8.9.0</span><br><span class="line"> marked                ^4.0.6  →  ^4.0.12</span><br><span class="line"> utf-8-validate        ^5.0.7  →   ^5.0.8</span><br><span class="line"></span><br><span class="line">Run npm install to install new versions.</span><br></pre></td></tr></table></figure><ul><li>更新指定依赖包到<code>package.json</code>中：<code>ncu -u  包名</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ ncu -u react-dev-inspector react-dom  react-helmet-async</span><br><span class="line">Upgrading D:\code\openbastion\src\web_ui\package.json</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> react-dev-inspector   ^1.7.0  →   ^1.8.1</span><br><span class="line"> react-dom            ^17.0.0  →  ^18.2.0</span><br><span class="line"> react-helmet-async    ^1.2.0  →   ^1.3.0</span><br><span class="line"></span><br><span class="line">Run npm install to install new versions.</span><br></pre></td></tr></table></figure><ul><li>更新依赖包:   <code>npm install</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ npm install</span><br><span class="line"></span><br><span class="line">added 7 packages, removed 3 packages, and changed 66 packages in 2m</span><br><span class="line"></span><br><span class="line">3 packages are looking for funding</span><br><span class="line">  run `npm fund` for details</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">NPM是随同NodeJS一起安装的包管理工具，能解决NodeJS代码部署上的很多问题，本文主要对NPM的基本使用、依赖包的升级方法等进行简要的记录说明。</summary>
    
    
    
    <category term="npm" scheme="https://blog.wuhui2356.top/categories/npm/"/>
    
    
    <category term="npm" scheme="https://blog.wuhui2356.top/tags/npm/"/>
    
  </entry>
  
  <entry>
    <title>Linux下常用调试方法命令</title>
    <link href="https://blog.wuhui2356.top/2022/01/07/linux%E4%B8%8B%E5%B8%B8%E7%94%A8%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95%E5%91%BD%E4%BB%A4/"/>
    <id>https://blog.wuhui2356.top/2022/01/07/linux%E4%B8%8B%E5%B8%B8%E7%94%A8%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95%E5%91%BD%E4%BB%A4/</id>
    <published>2022-01-07T12:22:00.000Z</published>
    <updated>2022-12-04T13:54:40.124Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GDB调试"><a href="#GDB调试" class="headerlink" title="GDB调试"></a>GDB调试</h1><ul><li><p>编译说明</p><ul><li>需要通过GDB进行调试的程序，在进行编译时需要指定 <code>-g</code> 选项</li></ul></li><li><p>启动参数</p><ul><li>–directory: 指定调试时加载的源代码文件路径<ul><li>例如:  <code>gdb --directory /opt/nginx/src --args  /opt/nginx/sbin/nginx -g &quot;daemon off;&quot;</code></li></ul></li><li>–args:  后面直接跟 命令+参数，当再gdb中启动调试时，会以指定的参数启动程序<ul><li>例如:  <code>gdb --args  /opt/nginx/sbin/nginx -g &quot;daemon off;&quot;</code></li></ul></li><li>-x: 从指定文件中加载断点信息</li></ul></li><li><p>常用调试命令</p><ul><li>info<ul><li>info breakpoints  ——  查看断点信息</li><li>info args  —— 查看当前函数的参数</li><li>info locals  —— 查看当前函数中的局部变量</li><li>info function  函数名 —— 进行函数查找，函数名支持通配符</li><li>info watch —— 查看所有的观察点</li></ul></li><li>run(r)： 重新开始运行程序</li><li>break(s)： 断点<ul><li>info breakpoints —— 查看所有断点信息</li><li>b    文件名:行号  —— 下断点到文件的指定行<ul><li>文件名可以省略，表示对针对当前文件下断点</li><li>例如： b 100       b  nginx.c:100</li></ul></li><li>b 函数名 —— 对指定函数下断点<ul><li>例如:  b main</li></ul></li><li>delete breakpoints  数字  —— 删除第几个断点</li><li>save breakpoints  aaa.txt —— 保存断点到指定文件，只能通过命令行参数从文件加载断点</li></ul></li><li>continue(c) —— 继续运行，直到程序结束或者命中下一个断点</li><li>step(s) —— 单步调试（逐条语句执行，会进入函数内部） </li><li>next(n) ——单步调试（逐过程执行，不会进入函数内部）</li><li>backtrace(bt) —— 查看函数当前的栈帧和调用层级关系</li></ul><p><img src="/2022/01/07/linux%E4%B8%8B%E5%B8%B8%E7%94%A8%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95%E5%91%BD%E4%BB%A4/image-20220107220700654.png" alt="image-20220107220700654"></p><ul><li><p>frame(f) —— 栈帧操作</p><ul><li>frame + 参数, 不指定参数则输出当前栈帧信息</li><li>例如：移动到栈帧2，再打印对应的变量信息</li></ul><p><img src="/2022/01/07/linux%E4%B8%8B%E5%B8%B8%E7%94%A8%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95%E5%91%BD%E4%BB%A4/image-20220107204208438.png" alt="image-20220107204208438"></p></li><li><p>print(p) —— 打印值或地址信息</p></li><li><p>watch(w) —— 设置观察点，被观察的变量发生修改时，打印显示</p></li></ul></li><li><p>多线程调试</p><ul><li>thread: <ul><li>thread apply all   cmd:  所有线程中执行指定的GDB命令<ul><li>例如: thread apply all bt: 所有线程执行bt打印当前的调用栈</li></ul></li><li>thread apply 线程ID  cmd: 执行线程执行指定的GDB命令</li></ul></li></ul></li><li><p>常用设置</p><ul><li>set print elements 0:   打印字符串指针的所有内容，不进行截断</li><li>set scheduler-locking on: 只运行当前线程</li><li>set  follow-fork-mode  [parent|child]:  设置调试  [父进程|子进程]</li><li>show  follow-fork-mode:  查看当前调试的父进程还是子进程</li><li>set  detach-on-fork  [on|off]:  设置调试当前进程时 [ 继续运行|挂起 ]  其他进程</li><li>show detach-on-fork  [on|off]:  查看调试当前进程时继续运行还是挂起其他进程</li><li>set logging on 文件名: 将调试信息输出到指定文件</li><li>set pagination of: 关闭分页暂停的提示信息</li></ul></li></ul><h1 id="strace"><a href="#strace" class="headerlink" title="strace"></a>strace</h1><ul><li>说明<ul><li>跟踪程序或进程的系统调用</li><li>当我们怀疑某个进程卡死或者跑飞的时候</li><li>查看进程打开了哪些文件</li><li>查看进程当前卡在哪个系统调用</li><li>………….</li></ul></li><li>使用方法：<ul><li>strace -p  进程号 —— 查看正在运行的进程的系统调用</li><li>strace  进程路径 —— 通过strace命令启动进程，查看进程的系统调用信息</li></ul></li></ul>]]></content>
    
    
    <summary type="html">我们在linux下进行程序开发时，通常会遇到需要进行调试的情况，与windows下的调试不同，windows下有非常方便的可视化调试工具，而linux下的调试工具大多都是在命令行中进行的，本文主要对linux下一些常用调试工具的使用做一些简单的介绍。</summary>
    
    
    
    <category term="Linux" scheme="https://blog.wuhui2356.top/categories/linux/"/>
    
    
    <category term="Linux" scheme="https://blog.wuhui2356.top/tags/linux/"/>
    
    <category term="调试" scheme="https://blog.wuhui2356.top/tags/%E8%B0%83%E8%AF%95/"/>
    
    <category term="gdb" scheme="https://blog.wuhui2356.top/tags/gdb/"/>
    
    <category term="strace" scheme="https://blog.wuhui2356.top/tags/strace/"/>
    
  </entry>
  
  <entry>
    <title>Linux 下扩展磁盘分区</title>
    <link href="https://blog.wuhui2356.top/2021/12/14/linux-%E6%89%A9%E5%B1%95%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA/"/>
    <id>https://blog.wuhui2356.top/2021/12/14/linux-%E6%89%A9%E5%B1%95%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA/</id>
    <published>2021-12-14T06:00:35.000Z</published>
    <updated>2021-12-14T07:10:15.248Z</updated>
    
    <content type="html"><![CDATA[<h1 id="查看磁盘信息"><a href="#查看磁盘信息" class="headerlink" title="查看磁盘信息"></a>查看磁盘信息</h1><h2 id="查看磁盘使用状态"><a href="#查看磁盘使用状态" class="headerlink" title="查看磁盘使用状态"></a>查看磁盘使用状态</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# df -h</span><br><span class="line">Filesystem               Size  Used Avail Use% Mounted on</span><br><span class="line">devtmpfs                 1.9G     0  1.9G   0% /dev</span><br><span class="line">tmpfs                    1.9G     0  1.9G   0% /dev/shm</span><br><span class="line">tmpfs                    1.9G   12M  1.9G   1% /run</span><br><span class="line">tmpfs                    1.9G     0  1.9G   0% /sys/fs/cgroup</span><br><span class="line">/dev/mapper/centos-root   18G   18G  9.2M 100% /</span><br><span class="line">/dev/sda1                497M  169M  329M  34% /boot</span><br><span class="line">/dev/sdb1                100G  1.8G   99G   2% /home</span><br><span class="line">tmpfs                    378M     0  378M   0% /run/user/0</span><br></pre></td></tr></table></figure><h2 id="查看磁盘分区结构"><a href="#查看磁盘分区结构" class="headerlink" title="查看磁盘分区结构"></a>查看磁盘分区结构</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# lsblk</span><br><span class="line">NAME                       MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</span><br><span class="line">sda                          8:0    0   20G  0 disk</span><br><span class="line">├─sda1                       8:1    0  500M  0 part /boot</span><br><span class="line">└─sda2                       8:2    0 19.5G  0 part</span><br><span class="line">  ├─centos-root            253:0    0 17.5G  0 lvm  /</span><br><span class="line">  └─centos-swap            253:1    0    2G  0 lvm  [SWAP]</span><br><span class="line">sdb                          8:16   0  100G  0 disk</span><br><span class="line">└─sdb1                       8:17   0  100G  0 part /home</span><br></pre></td></tr></table></figure><ul><li>由上面的信息可知，我们当前系统的根分区空间满了，需要进行扩容操作。</li></ul><h1 id="添加磁盘及分区"><a href="#添加磁盘及分区" class="headerlink" title="添加磁盘及分区"></a>添加磁盘及分区</h1><h2 id="添加磁盘"><a href="#添加磁盘" class="headerlink" title="添加磁盘"></a>添加磁盘</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# lsblk</span><br><span class="line">NAME                       MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</span><br><span class="line">sda                          8:0    0   20G  0 disk</span><br><span class="line">├─sda1                       8:1    0  500M  0 part /boot</span><br><span class="line">└─sda2                       8:2    0 19.5G  0 part</span><br><span class="line">  ├─centos-root            253:0    0 17.5G  0 lvm  /</span><br><span class="line">  └─centos-swap            253:1    0    2G  0 lvm  [SWAP]</span><br><span class="line">sdb                          8:16   0  100G  0 disk</span><br><span class="line">└─sdb1                       8:17   0  100G  0 part /home</span><br><span class="line">sdc                          8:32   0   50G  0 disk</span><br></pre></td></tr></table></figure><ul><li>如上所示，我们添加了一块磁盘，sdc，未进行任何格式化或者分区操作</li></ul><h2 id="创建分区表"><a href="#创建分区表" class="headerlink" title="创建分区表"></a>创建分区表</h2><ul><li>由于磁盘空间只有50G，故这里对分区表没有要求，使用<code>msdos</code>或者<code>GPT</code>分区都行。注意如果空间大小超过了2TB，则必须采用GPT分区表。这里我们采用GPT分区表。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 创建GPT分区表</span><br><span class="line">[root@localhost ~]# parted /dev/sdc  mklabel GPT</span><br><span class="line">Information: You may need to update /etc/fstab.</span><br><span class="line"></span><br><span class="line"># 查看磁盘信息</span><br><span class="line">[root@localhost ~]# parted /dev/sdc print</span><br><span class="line">Model: VMware, VMware Virtual S (scsi)</span><br><span class="line">Disk /dev/sdc: 53.7GB</span><br><span class="line">Sector size (logical/physical): 512B/512B</span><br><span class="line">Partition Table: gpt</span><br><span class="line">Disk Flags:</span><br><span class="line"></span><br><span class="line">Number  Start  End  Size  File system  Name  Flags</span><br></pre></td></tr></table></figure><h2 id="创建分区"><a href="#创建分区" class="headerlink" title="创建分区"></a>创建分区</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 创建一个主分区，分区起始地址为1MiB</span><br><span class="line">[root@localhost ~]# parted /dev/sdc mkpart primary xfs 1MiB 100%FREE</span><br><span class="line">Information: You may need to update /etc/fstab.</span><br><span class="line"></span><br><span class="line"># 查看磁盘信息</span><br><span class="line">[root@localhost ~]# parted /dev/sdc print</span><br><span class="line">Model: VMware, VMware Virtual S (scsi)</span><br><span class="line">Disk /dev/sdc: 53.7GB</span><br><span class="line">Sector size (logical/physical): 512B/512B</span><br><span class="line">Partition Table: gpt</span><br><span class="line">Disk Flags:</span><br><span class="line"></span><br><span class="line">Number  Start   End     Size    File system  Name     Flags</span><br><span class="line"> 1      1049kB  53.7GB  53.7GB               primary</span><br></pre></td></tr></table></figure><ul><li>由于我们的扩容策略是将该磁盘上所有的空间全部扩容到根分区，故这里我们只需要在该磁盘上创建一个分区，分区大小是整个磁盘的容量大小即可。这里采用了1MIB对齐。</li></ul><h1 id="扩容指定分区"><a href="#扩容指定分区" class="headerlink" title="扩容指定分区"></a>扩容指定分区</h1><h2 id="创建物理卷"><a href="#创建物理卷" class="headerlink" title="创建物理卷"></a>创建物理卷</h2><ul><li>分区扩容我们是通过逻辑卷来完成了，首先我们先在上面创建的分区上创建物理卷</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 创建物理卷</span><br><span class="line">[root@localhost ~]# pvcreate /dev/sdc1</span><br><span class="line">  Physical volume &quot;/dev/sdc1&quot; successfully created.</span><br><span class="line"></span><br><span class="line"># 查看物理卷信息</span><br><span class="line">[root@localhost ~]# pvdisplay /dev/sdc1</span><br><span class="line">  &quot;/dev/sdc1&quot; is a new physical volume of &quot;&lt;50.00 GiB&quot;</span><br><span class="line">  --- NEW Physical volume ---</span><br><span class="line">  PV Name               /dev/sdc1</span><br><span class="line">  VG Name</span><br><span class="line">  PV Size               &lt;50.00 GiB</span><br><span class="line">  Allocatable           NO</span><br><span class="line">  PE Size               0</span><br><span class="line">  Total PE              0</span><br><span class="line">  Free PE               0</span><br><span class="line">  Allocated PE          0</span><br><span class="line">  PV UUID               0hRpcz-o6gQ-4MtD-MuGs-ltT3-RoVk-3E9Oc5</span><br></pre></td></tr></table></figure><h2 id="查找目标卷组"><a href="#查找目标卷组" class="headerlink" title="查找目标卷组"></a>查找目标卷组</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"># 查看逻辑卷信息</span><br><span class="line">[root@localhost ~]# lvdisplay</span><br><span class="line">  --- Logical volume ---</span><br><span class="line">  LV Path                /dev/centos/swap</span><br><span class="line">  LV Name                swap</span><br><span class="line">  VG Name                centos</span><br><span class="line">  LV UUID                60jdcJ-NQfJ-MT4K-rcrp-Gmbp-OY2S-gfdapy</span><br><span class="line">  LV Write Access        read/write</span><br><span class="line">  LV Creation host, time localhost, 2018-07-08 05:32:48 +0800</span><br><span class="line">  LV Status              available</span><br><span class="line">  # open                 2</span><br><span class="line">  LV Size                2.00 GiB</span><br><span class="line">  Current LE             512</span><br><span class="line">  Segments               1</span><br><span class="line">  Allocation             inherit</span><br><span class="line">  Read ahead sectors     auto</span><br><span class="line">  - currently set to     8192</span><br><span class="line">  Block device           253:1</span><br><span class="line"></span><br><span class="line">  --- Logical volume ---</span><br><span class="line">  LV Path                /dev/centos/root</span><br><span class="line">  LV Name                root</span><br><span class="line">  VG Name                centos</span><br><span class="line">  LV UUID                0D5etc-7klz-Im4Y-GHAs-0O8W-mrCU-JZCXGY</span><br><span class="line">  LV Write Access        read/write</span><br><span class="line">  LV Creation host, time localhost, 2018-07-08 05:32:49 +0800</span><br><span class="line">  LV Status              available</span><br><span class="line">  # open                 1</span><br><span class="line">  LV Size                &lt;17.47 GiB</span><br><span class="line">  Current LE             4472</span><br><span class="line">  Segments               1</span><br><span class="line">  Allocation             inherit</span><br><span class="line">  Read ahead sectors     auto</span><br><span class="line">  - currently set to     8192</span><br><span class="line">  Block device           253:0</span><br></pre></td></tr></table></figure><ul><li>由于我们扩容的逻辑卷是 &#x2F;dev&#x2F;centos&#x2F;root, 故其对应的卷组为centos，所以我们需要将新创建的物理卷 添加到centos这个卷组中</li></ul><h2 id="卷组扩容"><a href="#卷组扩容" class="headerlink" title="卷组扩容"></a>卷组扩容</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"># 将物理卷 /dev/sdc1 添加到卷组centos中</span><br><span class="line">[root@localhost ~]# vgextend centos /dev/sdc1</span><br><span class="line">  Volume group &quot;centos&quot; successfully extended</span><br><span class="line"></span><br><span class="line"># 查看卷组centos的信息</span><br><span class="line">[root@localhost ~]# vgdisplay  centos</span><br><span class="line">  --- Volume group ---</span><br><span class="line">  VG Name               centos</span><br><span class="line">  System ID</span><br><span class="line">  Format                lvm2</span><br><span class="line">  Metadata Areas        2</span><br><span class="line">  Metadata Sequence No  5</span><br><span class="line">  VG Access             read/write</span><br><span class="line">  VG Status             resizable</span><br><span class="line">  MAX LV                0</span><br><span class="line">  Cur LV                2</span><br><span class="line">  Open LV               2</span><br><span class="line">  Max PV                0</span><br><span class="line">  Cur PV                2</span><br><span class="line">  Act PV                2</span><br><span class="line">  VG Size               69.50 GiB</span><br><span class="line">  PE Size               4.00 MiB</span><br><span class="line">  Total PE              17793</span><br><span class="line">  Alloc PE / Size       4984 / &lt;19.47 GiB</span><br><span class="line">  Free  PE / Size       12809 / &lt;50.04 GiB</span><br><span class="line">  VG UUID               j21OCZ-h3yM-KMAD-fUdc-2KxW-wM1p-qhxcoa</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 查看物理卷信息，此时物理卷信息中的卷组已经是centos了</span><br><span class="line">[root@localhost ~]# pvdisplay /dev/sdc1</span><br><span class="line">  --- Physical volume ---</span><br><span class="line">  PV Name               /dev/sdc1</span><br><span class="line">  VG Name               centos</span><br><span class="line">  PV Size               &lt;50.00 GiB / not usable 2.00 MiB</span><br><span class="line">  Allocatable           yes</span><br><span class="line">  PE Size               4.00 MiB</span><br><span class="line">  Total PE              12799</span><br><span class="line">  Free PE               12799</span><br><span class="line">  Allocated PE          0</span><br><span class="line">  PV UUID               0hRpcz-o6gQ-4MtD-MuGs-ltT3-RoVk-3E9Oc5</span><br></pre></td></tr></table></figure><h2 id="逻辑卷扩容"><a href="#逻辑卷扩容" class="headerlink" title="逻辑卷扩容"></a>逻辑卷扩容</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># 逻辑卷扩容 50G</span><br><span class="line">[root@localhost ~]# lvextend  -L &quot;+50G&quot; /dev/centos/root</span><br><span class="line">  Size of logical volume centos/root changed from &lt;17.47 GiB (4472 extents) to &lt;67.47 GiB (17272 extents).</span><br><span class="line">  Logical volume centos/root successfully resized.</span><br><span class="line"></span><br><span class="line"># 查看逻辑卷信息</span><br><span class="line">[root@localhost ~]# lvdisplay /dev/centos/root</span><br><span class="line">  --- Logical volume ---</span><br><span class="line">  LV Path                /dev/centos/root</span><br><span class="line">  LV Name                root</span><br><span class="line">  VG Name                centos</span><br><span class="line">  LV UUID                0D5etc-7klz-Im4Y-GHAs-0O8W-mrCU-JZCXGY</span><br><span class="line">  LV Write Access        read/write</span><br><span class="line">  LV Creation host, time localhost, 2018-07-08 05:32:49 +0800</span><br><span class="line">  LV Status              available</span><br><span class="line">  # open                 1</span><br><span class="line">  LV Size                &lt;67.47 GiB</span><br><span class="line">  Current LE             17272</span><br><span class="line">  Segments               2</span><br><span class="line">  Allocation             inherit</span><br><span class="line">  Read ahead sectors     auto</span><br><span class="line">  - currently set to     8192</span><br><span class="line">  Block device           253:0</span><br></pre></td></tr></table></figure><h2 id="文件系统扩容"><a href="#文件系统扩容" class="headerlink" title="文件系统扩容"></a>文件系统扩容</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># 对根分区的文件系统进行扩容</span><br><span class="line">[root@localhost ~]# xfs_growfs /</span><br><span class="line">meta-data=/dev/mapper/centos-root isize=256    agcount=4, agsize=1144832 blks</span><br><span class="line">         =                       sectsz=512   attr=2, projid32bit=1</span><br><span class="line">         =                       crc=0        finobt=0 spinodes=0</span><br><span class="line">data     =                       bsize=4096   blocks=4579328, imaxpct=25</span><br><span class="line">         =                       sunit=0      swidth=0 blks</span><br><span class="line">naming   =version 2              bsize=4096   ascii-ci=0 ftype=0</span><br><span class="line">log      =internal               bsize=4096   blocks=2560, version=2</span><br><span class="line">         =                       sectsz=512   sunit=0 blks, lazy-count=1</span><br><span class="line">realtime =none                   extsz=4096   blocks=0, rtextents=0</span><br><span class="line">data blocks changed from 4579328 to 17686528</span><br><span class="line"></span><br><span class="line"># 查看分区大小</span><br><span class="line">[root@localhost ~]# df -h</span><br><span class="line">Filesystem               Size  Used Avail Use% Mounted on</span><br><span class="line">devtmpfs                 1.9G     0  1.9G   0% /dev</span><br><span class="line">tmpfs                    1.9G     0  1.9G   0% /dev/shm</span><br><span class="line">tmpfs                    1.9G   12M  1.9G   1% /run</span><br><span class="line">tmpfs                    1.9G     0  1.9G   0% /sys/fs/cgroup</span><br><span class="line">/dev/mapper/centos-root   68G   18G   51G  26% /</span><br><span class="line">/dev/sda1                497M  169M  329M  34% /boot</span><br><span class="line">/dev/sdb1                100G  1.8G   99G   2% /home</span><br><span class="line">tmpfs                    378M     0  378M   0% /run/user/0</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">我们在使用Linux作为虚拟机进行日常开发工作，经常会遇到某个磁盘空间不足的情况，这时通常需要进行扩容操作。</summary>
    
    
    
    <category term="Linux" scheme="https://blog.wuhui2356.top/categories/linux/"/>
    
    
    <category term="Linux" scheme="https://blog.wuhui2356.top/tags/linux/"/>
    
    <category term="分区" scheme="https://blog.wuhui2356.top/tags/%E5%88%86%E5%8C%BA/"/>
    
    <category term="parted" scheme="https://blog.wuhui2356.top/tags/parted/"/>
    
    <category term="逻辑卷" scheme="https://blog.wuhui2356.top/tags/%E9%80%BB%E8%BE%91%E5%8D%B7/"/>
    
  </entry>
  
  <entry>
    <title>常用工具国内镜像源配置</title>
    <link href="https://blog.wuhui2356.top/2021/12/13/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E5%9B%BD%E5%86%85%E9%95%9C%E5%83%8F%E6%BA%90%E9%85%8D%E7%BD%AE/"/>
    <id>https://blog.wuhui2356.top/2021/12/13/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E5%9B%BD%E5%86%85%E9%95%9C%E5%83%8F%E6%BA%90%E9%85%8D%E7%BD%AE/</id>
    <published>2021-12-13T06:32:25.000Z</published>
    <updated>2021-12-14T07:10:15.249Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们的日常开发过程中会使用到很多的第三方工具，但是由于大部分工具的源（扩展包、库）都在国外，在线下载非常慢，耗时久。但是一般情况下，国内的大厂或者一些高校等都会对常用的工具免费提供对应的镜像仓库，故在我们的开发过程中直接使用国内的镜像网站，即可加速下载，节约大量的时间。</p><h1 id="npm-国内镜像源配置"><a href="#npm-国内镜像源配置" class="headerlink" title="npm 国内镜像源配置"></a>npm 国内镜像源配置</h1><p><code>NPM</code>（Node Package Manager），是<code>NodeJs</code>的模块依赖管理工具。一般情况下使用淘宝的源即可，可以直接执行以下命令进行配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 临时配置</span><br><span class="line">npm --registry https://registry.npm.taobao.org install express</span><br><span class="line"></span><br><span class="line">// 持久化配置</span><br><span class="line">npm config set registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p>配置完成后可以执行以下命令查看当前使用的源：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm info express</span><br><span class="line"></span><br><span class="line">npm config get registry</span><br></pre></td></tr></table></figure><h1 id="Golang-代理配置"><a href="#Golang-代理配置" class="headerlink" title="Golang 代理配置"></a>Golang 代理配置</h1><p><strong>Go</strong>（又称 <strong>Golang</strong>）是 Google 的 Robert Griesemer，Rob Pike 及 Ken Thompson 开发的一种静态强类型、编译型语言。Go 语言语法与 C相近，但功能上有：内存安全，GC(垃圾回收），结构形态及 CSP-style 并发计算。需要下载除SDK中自带的库时，可以直接使用以下代理地址：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://goproxy.cn</span><br><span class="line">https://goproxy.io</span><br></pre></td></tr></table></figure><p>直接添加以下环境变量即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export GO111MODULE=on</span><br><span class="line">export GOPROXY=https://goproxy.cn,direct</span><br></pre></td></tr></table></figure><p>在GoLand中进行如下图所示的设置即可：</p><p><img src="/images/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E5%9B%BD%E5%86%85%E9%95%9C%E5%83%8F%E6%BA%90%E9%85%8D%E7%BD%AE/goland%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%90%86%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="image-20200204103513496"></p><p>然后通过以下命令下载对应的包即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get &lt;package&gt;</span><br></pre></td></tr></table></figure><p>参考链接：</p><p><a href="https://github.com/goproxy/goproxy.cn/blob/master/README.zh-CN.md">GoProxy中国</a></p>]]></content>
    
    
    <summary type="html">记录一些常用工具的国内镜像源配置方法，比如npm、golang等。</summary>
    
    
    
    <category term="其他" scheme="https://blog.wuhui2356.top/categories/%E5%85%B6%E4%BB%96/"/>
    
    
    <category term="npm" scheme="https://blog.wuhui2356.top/tags/npm/"/>
    
    <category term="工具" scheme="https://blog.wuhui2356.top/tags/%E5%B7%A5%E5%85%B7/"/>
    
    <category term="node" scheme="https://blog.wuhui2356.top/tags/node/"/>
    
    <category term="maven" scheme="https://blog.wuhui2356.top/tags/maven/"/>
    
    <category term="mvn" scheme="https://blog.wuhui2356.top/tags/mvn/"/>
    
    <category term="golang" scheme="https://blog.wuhui2356.top/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>逻辑卷LVM相关操作</title>
    <link href="https://blog.wuhui2356.top/2021/12/13/%E9%80%BB%E8%BE%91%E5%8D%B7LVM%E7%9B%B8%E5%85%B3%E7%9A%84%E6%93%8D%E4%BD%9C/"/>
    <id>https://blog.wuhui2356.top/2021/12/13/%E9%80%BB%E8%BE%91%E5%8D%B7LVM%E7%9B%B8%E5%85%B3%E7%9A%84%E6%93%8D%E4%BD%9C/</id>
    <published>2021-12-13T01:30:30.000Z</published>
    <updated>2022-02-07T04:21:04.308Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是逻辑卷"><a href="#什么是逻辑卷" class="headerlink" title="什么是逻辑卷"></a>什么是逻辑卷</h2><ul><li>逻辑卷（lv）是将几个磁盘分区或者块设备(pv，pv的id必须是8e的，pv可以位于不同的磁盘分区里，pv大小可以不一)组织起来形成一个大的扩展分区（vg,卷组，一个vg至少要包含一个pv。），该扩展分区不能直接用，需要将其划分成逻辑卷（lv）才能使用，lv可以格式化成不同的文件系统，挂载后直接使用。</li><li>lv的扩展和缩减是不会影响原有数据的，但逻辑卷缩减的风险大于逻辑卷扩展的风险。</li><li>逻辑卷可以支持快照功能。</li></ul><h2 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h2><ul><li><p>物理卷（PV, Physical Volume）</p><ul><li>物理卷就是指磁盘,磁盘分区或从逻辑上和磁盘分区具有同样功能的设备(如RAID)，是LVM的基本存储逻辑块，但和基本的物理存储介质（如分区、磁盘等）比较，却包含有和LVM相关的管理参数。当前LVM允许你在每个物理卷上保存这个物理卷的0至2份元数据拷贝.默认为1,保存在设备的开始处.为2时,在设备结束处保存第二份备份.</li></ul></li><li><p>卷组（VG, Volume Group）</p><ul><li>LVM卷组类似于非LVM系统中的物理硬盘，其由物理卷组成。能在卷组上创建一个或多个“LVM分区”（逻辑卷），LVM卷组由一个或多个物理卷组成。</li></ul></li><li><p>逻辑卷（LV, Logical Volume）</p><ul><li>LVM的逻辑卷类似于非LVM系统中的硬盘分区，在逻辑卷之上能建立文件系统(比如&#x2F;home或&#x2F;usr等)。</li></ul></li><li><p>线性逻辑卷 (Linear Volumes)</p><ul><li>一个线性逻辑卷聚合多个物理卷成为一个逻辑卷.比如,如果你有两个60GB硬盘,你能生成120GB的逻辑卷.</li></ul></li><li><p>条块化的逻辑卷(Striped Logical Volumes)</p><ul><li>当你写数据到此逻辑卷中时,文件系统能将数据放置到多个物理卷中.对于大量连接读写操作,他能改善数据I&#x2F;O效率.</li></ul></li><li><p>映像的逻辑卷(Mirrored Logical Volumes)</p><ul><li>映像在不同的设备上保存一致的数据.数据同时被写入原设备及映像设备.他提供设备之间的容错。</li></ul></li><li><p>快照卷(Snapshot Volumes)</p><ul><li>快照卷提供在特定瞬间的一个设备虚拟映像，当快照开始时，他复制一份对当前数据区域的改动，由于他优先执行这些改动，所以他能重构当前设备的状态。</li></ul></li><li><p>参考: <a href="https://www.cnblogs.com/shxdyz/articles/7834980.html">https://www.cnblogs.com/shxdyz/articles/7834980.html</a></p></li></ul><h2 id="查看逻辑卷信息"><a href="#查看逻辑卷信息" class="headerlink" title="查看逻辑卷信息"></a>查看逻辑卷信息</h2><h3 id="查看LV"><a href="#查看LV" class="headerlink" title="查看LV"></a>查看LV</h3><ul><li><p><code>lvscan</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# lvscan</span><br><span class="line">  ACTIVE            &#x27;/dev/centos/swap&#x27; [2.00 GiB] inherit</span><br><span class="line">  ACTIVE            &#x27;/dev/centos/root&#x27; [&lt;67.47 GiB] inherit</span><br></pre></td></tr></table></figure></li><li><p><code>lvdisplay</code></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# lvdisplay</span><br><span class="line">  --- Logical volume ---</span><br><span class="line">  LV Path                /dev/centos/swap</span><br><span class="line">  LV Name                swap</span><br><span class="line">  VG Name                centos</span><br><span class="line">  LV UUID                60jdcJ-NQfJ-MT4K-rcrp-Gmbp-OY2S-gfdapy</span><br><span class="line">  LV Write Access        read/write</span><br><span class="line">  LV Creation host, time localhost, 2018-07-08 05:32:48 +0800</span><br><span class="line">  LV Status              available</span><br><span class="line">  # open                 2</span><br><span class="line">  LV Size                2.00 GiB</span><br><span class="line">  Current LE             512</span><br><span class="line">  Segments               1</span><br><span class="line">  Allocation             inherit</span><br><span class="line">  Read ahead sectors     auto</span><br><span class="line">  - currently set to     8192</span><br><span class="line">  Block device           253:1</span><br><span class="line"></span><br><span class="line">  --- Logical volume ---</span><br><span class="line">  LV Path                /dev/centos/root</span><br><span class="line">  LV Name                root</span><br><span class="line">  VG Name                centos</span><br><span class="line">  LV UUID                0D5etc-7klz-Im4Y-GHAs-0O8W-mrCU-JZCXGY</span><br><span class="line">  LV Write Access        read/write</span><br><span class="line">  LV Creation host, time localhost, 2018-07-08 05:32:49 +0800</span><br><span class="line">  LV Status              available</span><br><span class="line">  # open                 1</span><br><span class="line">  LV Size                &lt;67.47 GiB</span><br><span class="line">  Current LE             17272</span><br><span class="line">  Segments               2</span><br><span class="line">  Allocation             inherit</span><br><span class="line">  Read ahead sectors     auto</span><br><span class="line">  - currently set to     8192</span><br><span class="line">  Block device           253:0</span><br></pre></td></tr></table></figure><h3 id="查看VG"><a href="#查看VG" class="headerlink" title="查看VG"></a>查看VG</h3><ul><li><p><code>vgscan</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vgscan</span><br><span class="line">  Reading volume groups from cache.</span><br><span class="line">  Found volume group &quot;centos&quot; using metadata type lvm2</span><br></pre></td></tr></table></figure></li><li><p><code>vgdisplay</code></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vgdisplay</span><br><span class="line">  --- Volume group ---</span><br><span class="line">  VG Name               centos</span><br><span class="line">  System ID</span><br><span class="line">  Format                lvm2</span><br><span class="line">  Metadata Areas        2</span><br><span class="line">  Metadata Sequence No  6</span><br><span class="line">  VG Access             read/write</span><br><span class="line">  VG Status             resizable</span><br><span class="line">  MAX LV                0</span><br><span class="line">  Cur LV                2</span><br><span class="line">  Open LV               2</span><br><span class="line">  Max PV                0</span><br><span class="line">  Cur PV                2</span><br><span class="line">  Act PV                2</span><br><span class="line">  VG Size               69.50 GiB</span><br><span class="line">  PE Size               4.00 MiB</span><br><span class="line">  Total PE              17793</span><br><span class="line">  Alloc PE / Size       17784 / &lt;69.47 GiB</span><br><span class="line">  Free  PE / Size       9 / 36.00 MiB</span><br><span class="line">  VG UUID               j21OCZ-h3yM-KMAD-fUdc-2KxW-wM1p-qhxcoa</span><br></pre></td></tr></table></figure><h3 id="查看PV"><a href="#查看PV" class="headerlink" title="查看PV"></a>查看PV</h3><ul><li><p><code>pvscan</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# pvscan</span><br><span class="line">  PV /dev/sda2   VG centos          lvm2 [&lt;19.51 GiB / 0    free]</span><br><span class="line">  PV /dev/sdc1   VG centos          lvm2 [&lt;50.00 GiB / 36.00 MiB free]</span><br><span class="line">  Total: 2 [69.50 GiB] / in use: 2 [69.50 GiB] / in no VG: 0 [0   ]</span><br></pre></td></tr></table></figure></li><li><p><code>pvdisplay</code></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# pvdisplay</span><br><span class="line">  --- Physical volume ---</span><br><span class="line">  PV Name               /dev/sda2</span><br><span class="line">  VG Name               centos</span><br><span class="line">  PV Size               19.51 GiB / not usable 3.00 MiB</span><br><span class="line">  Allocatable           yes (but full)</span><br><span class="line">  PE Size               4.00 MiB</span><br><span class="line">  Total PE              4994</span><br><span class="line">  Free PE               0</span><br><span class="line">  Allocated PE          4994</span><br><span class="line">  PV UUID               YK8Rel-8zLh-Ri9E-fMtJ-G5TQ-rOfD-Mkg4q5</span><br><span class="line"></span><br><span class="line">  --- Physical volume ---</span><br><span class="line">  PV Name               /dev/sdc1</span><br><span class="line">  VG Name               centos</span><br><span class="line">  PV Size               &lt;50.00 GiB / not usable 2.00 MiB</span><br><span class="line">  Allocatable           yes</span><br><span class="line">  PE Size               4.00 MiB</span><br><span class="line">  Total PE              12799</span><br><span class="line">  Free PE               9</span><br><span class="line">  Allocated PE          12790</span><br><span class="line">  PV UUID               0hRpcz-o6gQ-4MtD-MuGs-ltT3-RoVk-3E9Oc5</span><br></pre></td></tr></table></figure><h2 id="创建逻辑卷"><a href="#创建逻辑卷" class="headerlink" title="创建逻辑卷"></a>创建逻辑卷</h2><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ul><li>再创建逻辑卷时，应当先创建物理卷(pv)，再创建卷组(vg)，最后再创建逻辑卷(lv)</li></ul><h3 id="创建PV"><a href="#创建PV" class="headerlink" title="创建PV"></a>创建PV</h3><ul><li><code>pvcreate</code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pvcreate &lt;device&gt;</span><br><span class="line"></span><br><span class="line">// device: 要创建物理卷的设备路径</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# pvcreate /dev/sda1 </span><br><span class="line">  Physical volume &quot;/dev/sda1&quot; successfully created</span><br></pre></td></tr></table></figure></li></ul><h3 id="创建VG"><a href="#创建VG" class="headerlink" title="创建VG"></a>创建VG</h3><ul><li><code>vgcreate</code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vgcreate &lt;vg_name&gt; &lt;pv list&gt;</span><br><span class="line"></span><br><span class="line">// vg_name: 卷组名</span><br><span class="line">// device list: 要添加到卷组的物理卷pv列表</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# vgcreate vg_test /dev/sda1 /dev/sdc1 </span><br><span class="line">  Volume group &quot;vg_test&quot; successfully created</span><br></pre></td></tr></table></figure></li></ul><h3 id="修改卷组属性"><a href="#修改卷组属性" class="headerlink" title="修改卷组属性"></a>修改卷组属性</h3><ul><li><code>vgchange</code><ul><li>激活卷组: <code>vgchange -ay vg_test</code></li></ul></li></ul><h3 id="创建LV"><a href="#创建LV" class="headerlink" title="创建LV"></a>创建LV</h3><ul><li><code>lvcreate</code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">lvcreate -n &lt;lv_name&gt; -L &lt;size&gt; &lt;vg_name&gt; -y</span><br><span class="line">lvcreate -n &lt;lv_name&gt; -l &lt;size&gt; &lt;vg_name&gt; -y</span><br><span class="line"></span><br><span class="line">// -L: 指定大小(--size LogicalVolumeSize[bBsSkKmMgGtTpPeE])</span><br><span class="line">// -l: 可以指定百分比(--extents LogicalExtentsNumber[%&#123;VG|FREE|ORIGIN&#125;]),如 100%FREE</span><br><span class="line"></span><br><span class="line">// lv_name: 逻辑卷名</span><br><span class="line">// size： 创建的卷大小</span><br><span class="line">// vg_name: 卷组名</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line">    lvcreate -n &quot;lv_swap&quot; -L &quot;2GiB&quot; &quot;vg_test&quot; -y</span><br><span class="line">    lvcreate -n &quot;lv_data&quot; -l &quot;100%FREE&quot; &quot;vg_test&quot; -y</span><br></pre></td></tr></table></figure></li></ul><h2 id="删除逻辑卷"><a href="#删除逻辑卷" class="headerlink" title="删除逻辑卷"></a>删除逻辑卷</h2><h3 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h3><ul><li>在删除逻辑卷之前，应当先卸载掉已经被挂载的分区，然后再进行逻辑卷的删除。<ul><li>在卸载分区时，如果遇到当前分区正在被使用，无法进行卸载的情况，可以借助<code>lsof</code>命令找到正在占用挂载点的进程，然后将其<code>kill</code>掉，再进行卸载在操作。</li></ul></li><li>逻辑卷的删除顺序与创建顺序相反，首先删除逻辑卷(lv)，然后删除卷组(vg)，最后删除物理卷(pv)</li></ul><h3 id="删除LV"><a href="#删除LV" class="headerlink" title="删除LV"></a>删除LV</h3><ul><li><code>lvremove</code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# lvremove /dev/VG_TEST/LV_SWAP -f -y</span><br><span class="line">  Logical volume &quot;LV_SWAP&quot; successfully removed</span><br></pre></td></tr></table></figure></li></ul><h3 id="删除VG"><a href="#删除VG" class="headerlink" title="删除VG"></a>删除VG</h3><ul><li><code>vgremove</code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vgremove VG_TEST -f -y</span><br><span class="line">  Volume group &quot;VG_TEST&quot; successfully removed</span><br></pre></td></tr></table></figure></li></ul><h3 id="删除PV"><a href="#删除PV" class="headerlink" title="删除PV"></a>删除PV</h3><ul><li><code>pvremove</code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# pvremove /dev/sdb1 -f -y</span><br><span class="line">  Labels on physical volume &quot;/dev/sdb1&quot; successfully wiped.</span><br></pre></td></tr></table></figure></li></ul><h2 id="磁盘分区"><a href="#磁盘分区" class="headerlink" title="磁盘分区"></a>磁盘分区</h2><h3 id="创建磁盘分区"><a href="#创建磁盘分区" class="headerlink" title="创建磁盘分区"></a>创建磁盘分区</h3><ul><li>创建分区表,采用 <code>msdos(MBR)</code>或者<code>GPT</code><ul><li><code>GPT</code>分区表: <code>parted -s /dev/sdd mklabel gpt</code></li><li><code>MBR</code>分区表: <code>parted -s /dev/sdd mklabel msdos</code></li></ul></li><li>创建主分区: <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">parted -s &lt;device&gt; mkpart &lt;part-type&gt; [fs-type] start end</span><br><span class="line"></span><br><span class="line">// deice: 指定磁盘设备</span><br><span class="line">// part-type: 只能为 primary(主分区)、logical(逻辑分区)、extended(扩展分区)</span><br><span class="line">// fs-type: 非必填参数,可以为: &quot;btrfs&quot;,  &quot;ext2&quot;,  &quot;ext3&quot;,  &quot;ext4&quot;,  &quot;fat16&quot;,  &quot;fat32&quot;, &quot;hfs&quot;, &quot;hfs+&quot;, &quot;linux-swap&quot;, &quot;ntfs&quot;, &quot;reiserfs&quot;, or &quot;xfs&quot;</span><br><span class="line">// start: 指定分区开始位置，默认为磁盘起始位置</span><br><span class="line">// end: 指定分区结束位置,默认为磁盘结束位置</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line">    parted -s /dev/sdd mkpart primary 4MiB 100%   </span><br><span class="line">    // 在 /dev/sdd 上创建一个主分区，从4MiB的位置开始，到磁盘末尾结束</span><br><span class="line">    // 即整个分区大小为 磁盘大小-4MiB</span><br></pre></td></tr></table></figure></li><li>修改分区表状态<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">parted -s &lt;device&gt; toggle &lt;partition_number&gt; &lt;status&gt;</span><br><span class="line"></span><br><span class="line">// device: 指定磁盘设备</span><br><span class="line">// partition_number: 该磁盘设备上的第几个分区</span><br><span class="line">// status: 转换后的状态(raid|lvm)</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line">    parted -s /dev/sdd toggle 1 &quot;lvm&quot;</span><br><span class="line">    // 将 /dev/sdd 上的第一个分区标记为 lvm</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="删除磁盘分区"><a href="#删除磁盘分区" class="headerlink" title="删除磁盘分区"></a>删除磁盘分区</h3><ul><li>可以通过<code>parted</code>删除指定的某个分区: <code>parted -s /dev/sdc rm 1</code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">parted -s &lt;device&gt; rm &lt;partition_number&gt;</span><br><span class="line"></span><br><span class="line">// device: 指定磁盘设备</span><br><span class="line">// partition_number: 该磁盘设备上的第几个分区</span><br><span class="line"></span><br><span class="line">示例: </span><br><span class="line">    parted -s /dev/sdc rm 1</span><br><span class="line">    // 删除 /dev/sdc 上的第一个分区</span><br><span class="line">    </span><br></pre></td></tr></table></figure></li><li>一般情况下，如果要摧毁整个磁盘分区，那么只需要将磁盘首部的分区表摧毁掉就行了，所以，可以直接采用<code>dd</code>命令: <code>dd if=/dev/zero of=/dev/sdd bs=16MiB count=1</code></li></ul><h3 id="磁盘格式化"><a href="#磁盘格式化" class="headerlink" title="磁盘格式化"></a>磁盘格式化</h3><ul><li><p>制作交换分区: <code>mkswap</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mkswap -f -L &lt;label&gt; &lt;device&gt;</span><br><span class="line"></span><br><span class="line">// device: 指定磁盘设备</span><br><span class="line">// label: 指定交换分区的标签label</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line"></span><br><span class="line">  mkswap -f -L label_swap /dev/vg_test/lv_swap</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>格式化: <code>mkfs</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mkfs.&lt;fs&gt; -L &lt;label&gt; &lt;device&gt;</span><br><span class="line"></span><br><span class="line">// fs: 文件系统格式</span><br><span class="line">// device: 指定磁盘设备</span><br><span class="line">// label: 指定交换分区的标签label</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line">    mkfs.xfs -L label_data /dev/vg_test/lv_data</span><br><span class="line">    mkfs.ext4 -L label_data /dev/vg_test/lv_data</span><br><span class="line"></span><br><span class="line">    mkfs -t xfs -L label_data /dev/vg_test/lv_data</span><br><span class="line">    mkfs -t ext4 -L label_data /dev/vg_test/lv_data</span><br></pre></td></tr></table></figure></li></ul><h2 id="数据无价，操作需谨慎"><a href="#数据无价，操作需谨慎" class="headerlink" title="数据无价，操作需谨慎"></a>数据无价，操作需谨慎</h2><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://blog.csdn.net/solaraceboy/article/details/78539233">https://blog.csdn.net/solaraceboy/article/details/78539233</a></li><li><a href="https://www.cnblogs.com/shxdyz/articles/7834980.html">https://www.cnblogs.com/shxdyz/articles/7834980.html</a></li></ul>]]></content>
    
    
    <summary type="html">逻辑卷是将几个磁盘分区或者块设备组织起来形成的一个大的扩展分区,该扩展分区不能直接用，需要将其划分成逻辑卷（lv）才能使用，lv可以格式化成不同的文件系统，挂载后直接使用。</summary>
    
    
    
    <category term="Linux" scheme="https://blog.wuhui2356.top/categories/linux/"/>
    
    
    <category term="Linux" scheme="https://blog.wuhui2356.top/tags/linux/"/>
    
    <category term="分区" scheme="https://blog.wuhui2356.top/tags/%E5%88%86%E5%8C%BA/"/>
    
    <category term="逻辑卷" scheme="https://blog.wuhui2356.top/tags/%E9%80%BB%E8%BE%91%E5%8D%B7/"/>
    
    <category term="LVM" scheme="https://blog.wuhui2356.top/tags/lvm/"/>
    
  </entry>
  
  <entry>
    <title>syslog协议</title>
    <link href="https://blog.wuhui2356.top/2021/12/10/syslog%E5%8D%8F%E8%AE%AE/"/>
    <id>https://blog.wuhui2356.top/2021/12/10/syslog%E5%8D%8F%E8%AE%AE/</id>
    <published>2021-12-10T09:38:00.000Z</published>
    <updated>2021-12-14T07:10:58.238Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li><code>syslog</code>协议属于一种主从式协议，通常被用于信息系统管理及信息安全审核。虽然它有不少缺陷，但仍获得相当多的设备及各种平台的接收端支持。因此<code>syslog</code>能被用来将来自许多不同类型系统的日志记录集成到集中的存储库中。</li></ul><h2 id="协议内容"><a href="#协议内容" class="headerlink" title="协议内容"></a>协议内容</h2><ul><li><code>syslog</code>格式为一个长字符串，整个数据报分为三个部分：<code>PRI</code>、<code>HEADER</code>、<code>MSG</code><ul><li><code>PRI</code>:  只能为3、4、5个字符，并且以小于符号开始，以大于符号结束，中间为一个1到3位的数字</li><li><code>HEADER</code>: 由<code>TimeStamp</code>与<code>HostName</code>组成。<code>HEADER</code>部分紧跟<code>PRI</code>，中间没有空格。<code>TimeStamp</code>与<code>HostName</code>之间间隔一个空格。<code>HostName</code>后面紧跟一个空格。<ul><li><code>TimeStamp</code>: 字段使用<code>local time</code>，格式为：<code>Mmm dd hh:mm:ss</code></li><li><code>Mmm</code>: 是英语月份的单词缩写，例如：Jan, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Oct, Nov, Dec</li><li><code>dd</code>: 某个月的多少号，固定宽度2个字符，不足两个字符在数字前面用空格填充。</li><li><code>hh:mm:ss</code>: 本地时间<ul><li><code>hh</code>: 24时制的小时，在00-23之间</li><li><code>mm</code>和<code>ss</code>： 分和秒，在00-59之间</li></ul></li><li><code>HostName</code>: 该字段为主机的<code>hostname</code>。该字段后面紧跟一个空格</li></ul></li><li><code>MSG</code>:  该字段又两部分组成： <code>TAG</code>和<code>CONTENT</code><ul><li><code>TAG</code>: 该字段的值为产生日志的程序名，即推送日志到外部系统的程序名（不超过32个字符）。<code>TAG</code>后面紧跟一个用中括号包含着的<code>pid</code>,即<code>[pid]</code>,并且再追加一个<code>:</code>,<code>pid</code>为该推送程序的进程号</li><li><code>CONTENT</code>: 该字段为具体的日志内容</li></ul></li></ul></li><li>综上，整个数据报为：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;xxx&gt;Mmm dd hh:mm:ss hostname tag[pid]: xxxxxxxxx</span><br></pre></td></tr></table></figure></li></ul><h2 id="rsyslog服务器配置"><a href="#rsyslog服务器配置" class="headerlink" title="rsyslog服务器配置"></a>rsyslog服务器配置</h2><h3 id="安装syslog服务"><a href="#安装syslog服务" class="headerlink" title="安装syslog服务"></a>安装<code>syslog</code>服务</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install rsyslog -y</span><br></pre></td></tr></table></figure><h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ModLoad imudp</span><br><span class="line">$UDPServerRun 514</span><br><span class="line"></span><br><span class="line">$ModLoad imtcp</span><br><span class="line">$InputTCPServerRun 514</span><br><span class="line"></span><br><span class="line">$template RemoteLogs,&quot;/var/log/%HOSTNAME%/%PROGRAMNAME%.log&quot; *</span><br><span class="line">*.*  ?RemoteLogs</span><br><span class="line">&amp; ~</span><br></pre></td></tr></table></figure><h3 id="启动rsyslog服务生效"><a href="#启动rsyslog服务生效" class="headerlink" title="启动rsyslog服务生效"></a>启动<code>rsyslog</code>服务生效</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart rsyslog</span><br></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2>]]></content>
    
    
    <summary type="html">syslog协议属于一种主从式协议，通常被用于信息系统管理及信息安全审核。虽然它有不少缺陷，但仍获得相当多的设备及各种平台的接收端支持。因此syslog能被用来将来自许多不同类型系统的日志记录集成到集中的存储库中。</summary>
    
    
    
    <category term="Linux" scheme="https://blog.wuhui2356.top/categories/linux/"/>
    
    
    <category term="syslog" scheme="https://blog.wuhui2356.top/tags/syslog/"/>
    
    <category term="linux" scheme="https://blog.wuhui2356.top/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Docker常用命令</title>
    <link href="https://blog.wuhui2356.top/2021/12/03/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://blog.wuhui2356.top/2021/12/03/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</id>
    <published>2021-12-03T13:44:25.000Z</published>
    <updated>2022-02-13T14:04:00.622Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="CentOS"><a href="#CentOS" class="headerlink" title="CentOS"></a>CentOS</h2><ul><li><p>卸载旧版docker</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo yum remove docker \</span><br><span class="line">                 docker-client \</span><br><span class="line">                 docker-client-latest \</span><br><span class="line">                 docker-common \</span><br><span class="line">                 docker-latest \</span><br><span class="line">                 docker-latest-logrotate \</span><br><span class="line">                 docker-logrotate \</span><br><span class="line">                 docker-engine</span><br></pre></td></tr></table></figure></li><li><p>添加仓库、源</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 先安装yum-utils工具</span><br><span class="line">sudo yum install yum-utils -y</span><br><span class="line"></span><br><span class="line"># 添加阿里云源</span><br><span class="line">sudo yum-config-manager --add-repo  http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line"># 官方源</span><br><span class="line">sudo yum-config-manager --add-repo  https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure></li><li><p>下载安装</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install docker-ce docker-ce-cli containerd.io -y</span><br></pre></td></tr></table></figure><ul><li>启动docker服务</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 启动</span><br><span class="line">sudo systemctl start docker</span><br><span class="line"></span><br><span class="line"># 停止</span><br><span class="line">sudo systemctl stop docker</span><br><span class="line"></span><br><span class="line"># 重启</span><br><span class="line">sudo systemctl restart docker</span><br><span class="line"></span><br><span class="line"># 开机自启</span><br><span class="line">sudo systemctl enable docker</span><br><span class="line"></span><br><span class="line"># 取消开机自启</span><br><span class="line">sudo systemctl disable docker</span><br></pre></td></tr></table></figure><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><h2 id="配置项"><a href="#配置项" class="headerlink" title="配置项"></a>配置项</h2><ul><li><p>修改源</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 配置文件: /etc/docker/daemon.json </span><br><span class="line">&#123;</span><br><span class="line">   &quot;registry-mirrors&quot;: [&quot;https://z34u8nau.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 重载配置文件</span><br><span class="line">systemctl daemon-reload</span><br><span class="line"></span><br><span class="line"># 重启服务</span><br><span class="line">systemctl restart docker</span><br><span class="line"></span><br><span class="line"># 可能会需要登录操作</span><br><span class="line">sudo docker login --username=用户名  registry.cn-hangzhou.aliyuncs.com</span><br></pre></td></tr></table></figure></li></ul><h2 id="镜像操作"><a href="#镜像操作" class="headerlink" title="镜像操作"></a>镜像操作</h2><ul><li><p>docker images</p><ul><li><p>查看当前已下载的镜像:  docker images</p></li><li><p>查看当前没有tag的镜像: docker images -f “dangling&#x3D;true”</p></li></ul></li><li><p>docker search</p><ul><li>查找镜像:   docker search xxxxx</li></ul></li><li><p>docker pull</p><ul><li>拉取镜像： docker  pull  xxxxx</li></ul></li><li><p>docker save</p><ul><li>导出镜像:   docker save  镜像tag   -o   xxx.tar</li></ul></li><li><p>docker rmi</p><ul><li><p>删除镜像:   docker rmi   镜像名称</p></li><li><p>删除没有tag的镜像:  docker rmi $(docker images -f “dangling&#x3D;true” -q)  -f</p></li></ul></li><li><p>docker imspect</p><ul><li>查看镜像的信息:  docker inspect  进行名称</li></ul></li></ul><h2 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a>容器操作</h2><ul><li><p>docker run</p><ul><li><p>启动容器:    docker run xxxx</p></li><li><p>交互式启动容器:    docker run -it  xxxx   &#x2F;bin&#x2F;bash</p></li><li><p>后台启动容器:   docker run -d xxxx   启动命令</p></li></ul></li><li><p>docker exec</p><ul><li>在指定容器中执行程序:  docker  exec -it 容器ID   CMD</li><li>例如: <code>docker exec -it aa7c1b0a86ca /bin/bash</code></li></ul></li><li><p>docker ps</p><ul><li>查看当前运行的容器:   docker ps</li></ul></li><li><p>docker logs</p><ul><li>查看容器的输出信息:  docker logs   容器ID</li></ul></li><li><p>docker stop</p><ul><li>停止容器:  docker stop 容器ID</li></ul></li><li><p>docker attach</p><ul><li>重新获取容器的终端： docker attach  容器ID</li></ul></li><li><p>docker export</p><ul><li>导出容器：docker export  容器ID  &gt;  xxxxx.img</li></ul></li><li><p>docker import</p><ul><li>导入容器:   cat  xxxx.img | docker import -   test&#x2F;ubuntu:v1</li></ul></li><li><p>docker rm</p><ul><li>删除容器:   docker rm -f 容器ID</li></ul></li></ul><h2 id="推送镜像"><a href="#推送镜像" class="headerlink" title="推送镜像"></a>推送镜像</h2><ul><li><p>修改配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#配置文件 /etc/docker/daemon.json </span><br><span class="line">&#123;</span><br><span class="line">   &quot;registry-mirrors&quot;: [&quot;https://z34u8nau.mirror.aliyuncs.com&quot;],</span><br><span class="line">   &quot;insecure-registries&quot;:[&quot;192.168.1.220:51005&quot;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#添加 insecure-registries 配置（本地的服务器地址和端口）</span><br></pre></td></tr></table></figure></li><li><p>推送镜像到本地仓库</p><ul><li>将镜像tag重命名:   docker tag registry:2.7.1   192.168.1.220:51005&#x2F;offline&#x2F;registry:2.7.1</li><li>推送镜像:   docker push   192.168.1.220:51005&#x2F;offline&#x2F;registry:2.7.1</li></ul></li></ul><h1 id="dockerfile"><a href="#dockerfile" class="headerlink" title="dockerfile"></a>dockerfile</h1><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>FROM</td><td>指定使用的基础镜像，基于哪个镜像来指针当前的镜像</td></tr><tr><td>RUN</td><td>在构建容器时，在容器内执行指定的Shell命令(docker build 时执行)</td></tr><tr><td>COPY</td><td>拷贝文件到容器中的指定目录</td></tr><tr><td>CMD</td><td>启动容器时，执行指定的命令(docker run 时执行，该命令与容器共存亡)，该命令结束，则容器运行结束。可被docker run命令行中指定的参数所覆盖。如果一个Dockerfile中存在多个CMD命令，则只有最后一条生效。</td></tr><tr><td>USER</td><td>指定镜像运行时，默认的用户身份</td></tr><tr><td>EXPOSE</td><td>声明容器的暴露端口</td></tr></tbody></table><ul><li>dockerfile文件示例</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">###################################################</span><br><span class="line">FROM centos:centos7.9.2009</span><br><span class="line">RUN yum install epel-release -y</span><br><span class="line">RUN yum install git cppcheck gcc gcc-c++ make cmake3 -y &amp;&amp; ln -sv cmake3 /usr/bin/cmake</span><br><span class="line">COPY  a.txt   /root/a.txt</span><br><span class="line">USER root</span><br></pre></td></tr></table></figure><ul><li>构建镜像</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker build -t nginx:v3 .</span><br><span class="line"></span><br><span class="line"># docker  build -t 标签名称  Dockerfile所在的目录</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">记录Docker相关的一些常用命令等。</summary>
    
    
    
    <category term="Linux" scheme="https://blog.wuhui2356.top/categories/linux/"/>
    
    
    <category term="Docker" scheme="https://blog.wuhui2356.top/tags/docker/"/>
    
    <category term="容器" scheme="https://blog.wuhui2356.top/tags/%E5%AE%B9%E5%99%A8/"/>
    
    <category term="Linux" scheme="https://blog.wuhui2356.top/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>nginx内存池管理</title>
    <link href="https://blog.wuhui2356.top/2021/01/03/nginx%E5%86%85%E5%AD%98%E6%B1%A0%E7%AE%A1%E7%90%86/"/>
    <id>https://blog.wuhui2356.top/2021/01/03/nginx%E5%86%85%E5%AD%98%E6%B1%A0%E7%AE%A1%E7%90%86/</id>
    <published>2021-01-03T23:44:00.000Z</published>
    <updated>2022-02-07T07:10:00.001Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul><li>ngx_pool_s——内存池管理结构</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct ngx_pool_s &#123;</span><br><span class="line">    ngx_pool_data_t       d;         // 用于小内存分配的data域</span><br><span class="line">    size_t                max;       // pool上单个节点的最大容量(不是可用容量)</span><br><span class="line">    ngx_pool_t           *current;   // 指向当前pool用于内存分配的pool节点</span><br><span class="line">    ngx_chain_t          *chain;</span><br><span class="line">    ngx_pool_large_t     *large;     // 链表,保存开辟的大内存空间</span><br><span class="line">    ngx_pool_cleanup_t   *cleanup;   // 需要回收的内存链表</span><br><span class="line">    ngx_log_t            *log;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>ngx_pool_data_t——管理用于内存分配的数据域</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    u_char               *last;       // 内存池下一次分配的起始地址</span><br><span class="line">    u_char               *end;        // 内存池的结束地址</span><br><span class="line">    ngx_pool_t           *next;       // 下一个内存池节点</span><br><span class="line">    ngx_uint_t            failed;     // 分配内存失败的次数</span><br><span class="line">&#125; ngx_pool_data_t;</span><br></pre></td></tr></table></figure><ul><li>ngx_pool_large_s——大内存块</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct ngx_pool_large_s &#123;</span><br><span class="line">    ngx_pool_large_t     *next;</span><br><span class="line">    void                 *alloc;      // 保存开辟的大内存块</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>ngx_pool_cleanup_s——自定义内存回收的结构</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct ngx_pool_cleanup_s &#123;</span><br><span class="line">    ngx_pool_cleanup_pt   handler;    // 用于回收内存的处理函数</span><br><span class="line">    void                 *data;       // 待回收的内存</span><br><span class="line">    ngx_pool_cleanup_t   *next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 进行自定义内存回收处理的回调函数</span><br><span class="line">typedef void (*ngx_pool_cleanup_pt)(void *data);</span><br></pre></td></tr></table></figure><ul><li>ngx_pool_cleanup_file_t——进行文件清理的结构</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    ngx_fd_t              fd;</span><br><span class="line">    u_char               *name;</span><br><span class="line">    ngx_log_t            *log;</span><br><span class="line">&#125; ngx_pool_cleanup_file_t;</span><br></pre></td></tr></table></figure><h2 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h2><p><img src="/2021/01/03/nginx%E5%86%85%E5%AD%98%E6%B1%A0%E7%AE%A1%E7%90%86/image-20220207132533893-16442147412281.png" alt="image-20220207132533893"></p><h2 id="分配流程"><a href="#分配流程" class="headerlink" title="分配流程"></a>分配流程</h2><ul><li><code>nginx</code>中进行内存分配的流程大致如下</li></ul><div id="flowchart-0" class="flow-chart"></div><h1 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h1><h2 id="接口函数"><a href="#接口函数" class="headerlink" title="接口函数"></a>接口函数</h2><h3 id="内存池操作"><a href="#内存池操作" class="headerlink" title="内存池操作"></a>内存池操作</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 创建单个节点大小为size的内存池</span><br><span class="line">ngx_pool_t *ngx_create_pool(size_t size, ngx_log_t *log);</span><br><span class="line"></span><br><span class="line">// 销毁释放内存池</span><br><span class="line">void ngx_destroy_pool(ngx_pool_t *pool);</span><br><span class="line"></span><br><span class="line">// 重置内存池为初始状态</span><br><span class="line">void ngx_reset_pool(ngx_pool_t *pool);</span><br></pre></td></tr></table></figure><h3 id="内存操作"><a href="#内存操作" class="headerlink" title="内存操作"></a>内存操作</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 通过内存池进行内存分配，并进行内存对齐</span><br><span class="line">void *ngx_palloc(ngx_pool_t *pool, size_t size);</span><br><span class="line"></span><br><span class="line">// 通过内存池进行内存分配，不进行内存对齐</span><br><span class="line">void *ngx_pnalloc(ngx_pool_t *pool, size_t size);</span><br><span class="line"></span><br><span class="line">// 通过内存池进行内存分配，进行内存对齐，并且将内存区域初始化为0</span><br><span class="line">void *ngx_pcalloc(ngx_pool_t *pool, size_t size);</span><br><span class="line"></span><br><span class="line">// 直接开辟size大小内存，并将该内存块保存在large链上</span><br><span class="line">void *ngx_pmemalign(ngx_pool_t *pool, size_t size, size_t alignment);</span><br><span class="line"></span><br><span class="line">// 内存释放，但是只会释放保存在large链上的大内存块，并且不会释放链表节点</span><br><span class="line">ngx_int_t ngx_pfree(ngx_pool_t *pool, void *p);</span><br></pre></td></tr></table></figure><h3 id="特殊操作"><a href="#特殊操作" class="headerlink" title="特殊操作"></a>特殊操作</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 在cleanup 链上添加一个节点并返回</span><br><span class="line">ngx_pool_cleanup_t *ngx_pool_cleanup_add(ngx_pool_t *p, size_t size);</span><br><span class="line"></span><br><span class="line">// 清理cleanup链上指定的fd</span><br><span class="line">void ngx_pool_run_cleanup_file(ngx_pool_t *p, ngx_fd_t fd);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 文件清理的处理函数</span><br><span class="line">// 该函数作为cleanup链上的handler</span><br><span class="line">void ngx_pool_cleanup_file(void *data);</span><br><span class="line"></span><br><span class="line">// 通过内存池的cleanup链删除文件，以及清理文件描述符</span><br><span class="line">// 该函数作为cleanup链上的handler</span><br><span class="line">void ngx_pool_delete_file(void *data);</span><br></pre></td></tr></table></figure><h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><h3 id="内存池操作-1"><a href="#内存池操作-1" class="headerlink" title="内存池操作"></a>内存池操作</h3><h4 id="ngx-create-pool"><a href="#ngx-create-pool" class="headerlink" title="ngx_create_pool"></a>ngx_create_pool</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">ngx_pool_t *</span><br><span class="line">ngx_create_pool(size_t size, ngx_log_t *log)</span><br><span class="line">&#123;</span><br><span class="line">    ngx_pool_t  *p;</span><br><span class="line"></span><br><span class="line">    // 开辟 size 大小的内存(通过malloc实现)</span><br><span class="line">    p = ngx_memalign(NGX_POOL_ALIGNMENT, size, log);</span><br><span class="line">    if (p == NULL) &#123;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 内存区域的首部预留  sizeof(ngx_pool_t) 的大小</span><br><span class="line">    // 作为内存管理结构的内存空间</span><br><span class="line">    p-&gt;d.last = (u_char *) p + sizeof(ngx_pool_t);</span><br><span class="line">    p-&gt;d.end = (u_char *) p + size;</span><br><span class="line">    p-&gt;d.next = NULL;</span><br><span class="line">    p-&gt;d.failed = 0;</span><br><span class="line"></span><br><span class="line">    size = size - sizeof(ngx_pool_t);</span><br><span class="line"></span><br><span class="line">    // p-&gt;max 最大只能为 pagesize -1 的大小</span><br><span class="line">    p-&gt;max = (size &lt; NGX_MAX_ALLOC_FROM_POOL) ? size : NGX_MAX_ALLOC_FROM_POOL;</span><br><span class="line"></span><br><span class="line">    p-&gt;current = p;</span><br><span class="line">    p-&gt;chain = NULL;</span><br><span class="line">    p-&gt;large = NULL;</span><br><span class="line">    p-&gt;cleanup = NULL;</span><br><span class="line">    p-&gt;log = log;</span><br><span class="line"></span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ngx-destroy-pool"><a href="#ngx-destroy-pool" class="headerlink" title="ngx_destroy_pool"></a>ngx_destroy_pool</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">ngx_destroy_pool(ngx_pool_t *pool)</span><br><span class="line">&#123;</span><br><span class="line">    ngx_pool_t          *p, *n;</span><br><span class="line">    ngx_pool_large_t    *l;</span><br><span class="line">    ngx_pool_cleanup_t  *c;</span><br><span class="line"></span><br><span class="line">    // 处理cleanup链上的数据,通过handler进行处理释放</span><br><span class="line">    for (c = pool-&gt;cleanup; c; c = c-&gt;next) &#123;</span><br><span class="line">        if (c-&gt;handler) &#123;</span><br><span class="line">            ngx_log_debug1(NGX_LOG_DEBUG_ALLOC, pool-&gt;log, 0,</span><br><span class="line">                           &quot;run cleanup: %p&quot;, c);</span><br><span class="line">            c-&gt;handler(c-&gt;data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">#if (NGX_DEBUG)</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * we could allocate the pool-&gt;log from this pool</span><br><span class="line">     * so we cannot use this log while free()ing the pool</span><br><span class="line">     */</span><br><span class="line">    // 打印large链上的节点和地址</span><br><span class="line">    for (l = pool-&gt;large; l; l = l-&gt;next) &#123;</span><br><span class="line">        ngx_log_debug1(NGX_LOG_DEBUG_ALLOC, pool-&gt;log, 0, &quot;free: %p&quot;, l-&gt;alloc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 打印内存池节点的地址和内存大小</span><br><span class="line">    for (p = pool, n = pool-&gt;d.next; /* void */; p = n, n = n-&gt;d.next) &#123;</span><br><span class="line">        ngx_log_debug2(NGX_LOG_DEBUG_ALLOC, pool-&gt;log, 0,</span><br><span class="line">                       &quot;free: %p, unused: %uz&quot;, p, p-&gt;d.end - p-&gt;d.last);</span><br><span class="line"></span><br><span class="line">        if (n == NULL) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    // 释放large链上的大内存</span><br><span class="line">    for (l = pool-&gt;large; l; l = l-&gt;next) &#123;</span><br><span class="line">        if (l-&gt;alloc) &#123;</span><br><span class="line">            ngx_free(l-&gt;alloc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 释放pool链</span><br><span class="line">    for (p = pool, n = pool-&gt;d.next; /* void */; p = n, n = n-&gt;d.next) &#123;</span><br><span class="line">        ngx_free(p);</span><br><span class="line"></span><br><span class="line">        if (n == NULL) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ngx-destroy-pool-1"><a href="#ngx-destroy-pool-1" class="headerlink" title="ngx_destroy_pool"></a>ngx_destroy_pool</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 重置内存池为初始状态</span><br><span class="line">void</span><br><span class="line">ngx_reset_pool(ngx_pool_t *pool)</span><br><span class="line">&#123;</span><br><span class="line">    ngx_pool_t        *p;</span><br><span class="line">    ngx_pool_large_t  *l;</span><br><span class="line"></span><br><span class="line">    // 释放large链上的大内存空间</span><br><span class="line">    for (l = pool-&gt;large; l; l = l-&gt;next) &#123;</span><br><span class="line">        if (l-&gt;alloc) &#123;</span><br><span class="line">            ngx_free(l-&gt;alloc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 重置内存池链上所有节点的内存，设为未使用状态</span><br><span class="line">    for (p = pool; p; p = p-&gt;d.next) &#123;</span><br><span class="line">        p-&gt;d.last = (u_char *) p + sizeof(ngx_pool_t);</span><br><span class="line">        p-&gt;d.failed = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // current链指向第一个节点</span><br><span class="line">    pool-&gt;current = pool;</span><br><span class="line">    pool-&gt;chain = NULL;</span><br><span class="line">    pool-&gt;large = NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="内存操作-1"><a href="#内存操作-1" class="headerlink" title="内存操作"></a>内存操作</h3><h4 id="ngx-palloc"><a href="#ngx-palloc" class="headerlink" title="ngx_palloc"></a>ngx_palloc</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 通过内存池分配内存，进行内存对齐</span><br><span class="line">void *</span><br><span class="line">ngx_palloc(ngx_pool_t *pool, size_t size)</span><br><span class="line">&#123;</span><br><span class="line">#if !(NGX_DEBUG_PALLOC)</span><br><span class="line">    // 如果请求的内存大小小于 pool-&gt;max, 则视为小内存,并且设置内存对齐</span><br><span class="line">    if (size &lt;= pool-&gt;max) &#123;</span><br><span class="line">        return ngx_palloc_small(pool, size, 1);</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    // 否则视为大内存</span><br><span class="line">    return ngx_palloc_large(pool, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ngx-pnalloc"><a href="#ngx-pnalloc" class="headerlink" title="ngx_pnalloc"></a>ngx_pnalloc</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 通过内存池分配内存，不进行内存对齐</span><br><span class="line">void *</span><br><span class="line">ngx_pnalloc(ngx_pool_t *pool, size_t size)</span><br><span class="line">&#123;</span><br><span class="line">#if !(NGX_DEBUG_PALLOC)</span><br><span class="line">    if (size &lt;= pool-&gt;max) &#123;</span><br><span class="line">        return ngx_palloc_small(pool, size, 0);</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    return ngx_palloc_large(pool, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ngx-pcalloc"><a href="#ngx-pcalloc" class="headerlink" title="ngx_pcalloc"></a>ngx_pcalloc</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 通过内存池进行内存分配，进行内存对齐，并且将内存区域初始化为0</span><br><span class="line">void *</span><br><span class="line">ngx_pcalloc(ngx_pool_t *pool, size_t size)</span><br><span class="line">&#123;</span><br><span class="line">    void *p;</span><br><span class="line"></span><br><span class="line">    p = ngx_palloc(pool, size);</span><br><span class="line">    if (p) &#123;</span><br><span class="line">        ngx_memzero(p, size);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ngx-pmemalign"><a href="#ngx-pmemalign" class="headerlink" title="ngx_pmemalign"></a>ngx_pmemalign</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 直接开辟size大小内存，并将该内存块保存在large链上</span><br><span class="line">void *</span><br><span class="line">ngx_pmemalign(ngx_pool_t *pool, size_t size, size_t alignment)</span><br><span class="line">&#123;</span><br><span class="line">    void              *p;</span><br><span class="line">    ngx_pool_large_t  *large;</span><br><span class="line"></span><br><span class="line">    // 开辟 size 大小的内存空间</span><br><span class="line">    p = ngx_memalign(alignment, size, pool-&gt;log);</span><br><span class="line">    if (p == NULL) &#123;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 在小空间池上分配 sizeof(ngx_pool_large_t) 大小的空间，用于保存上面开辟的空间</span><br><span class="line">    large = ngx_palloc_small(pool, sizeof(ngx_pool_large_t), 1);</span><br><span class="line">    if (large == NULL) &#123;</span><br><span class="line">        ngx_free(p);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 将开辟的空间保存在large链上</span><br><span class="line">    large-&gt;alloc = p;</span><br><span class="line">    large-&gt;next = pool-&gt;large;</span><br><span class="line">    pool-&gt;large = large;</span><br><span class="line"></span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="ngx-palloc-small"><a href="#ngx-palloc-small" class="headerlink" title="ngx_palloc_small"></a>ngx_palloc_small</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// 分配小块内存</span><br><span class="line">static ngx_inline void *</span><br><span class="line">ngx_palloc_small(ngx_pool_t *pool, size_t size, ngx_uint_t align)</span><br><span class="line">&#123;</span><br><span class="line">    u_char      *m;</span><br><span class="line">    ngx_pool_t  *p;</span><br><span class="line"></span><br><span class="line">    // 获取当前正在使用的内存池</span><br><span class="line">    p = pool-&gt;current;</span><br><span class="line"></span><br><span class="line">    do &#123;</span><br><span class="line">        m = p-&gt;d.last;</span><br><span class="line"></span><br><span class="line">        // 指定了内存对齐的情况下，按照 NGX_ALIGNMENT 对齐，调整待分配的首地址</span><br><span class="line">        if (align) &#123;</span><br><span class="line">            m = ngx_align_ptr(m, NGX_ALIGNMENT);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 如果剩余空间充足，则调整last指针后，直接返回 m 的地址</span><br><span class="line">        if ((size_t) (p-&gt;d.end - m) &gt;= size) &#123;</span><br><span class="line">            p-&gt;d.last = m + size;</span><br><span class="line"></span><br><span class="line">            return m;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 当前节点的空间不足，则移动到下一节点继续以上操作</span><br><span class="line">        p = p-&gt;d.next;</span><br><span class="line"></span><br><span class="line">    &#125; while (p);</span><br><span class="line"></span><br><span class="line">    // 如果从current节点开始，遍历完所有的节点后，均不能找到合适的内存池进行空间分配，</span><br><span class="line">    // 则通过以下方法，在操作系统重新开辟一个新的内存池，进行内存分配</span><br><span class="line">    return ngx_palloc_block(pool, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ngx-palloc-block"><a href="#ngx-palloc-block" class="headerlink" title="ngx_palloc_block"></a>ngx_palloc_block</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">// 内存不足时，开辟新的内存池节点</span><br><span class="line">static void *</span><br><span class="line">ngx_palloc_block(ngx_pool_t *pool, size_t size)</span><br><span class="line">&#123;</span><br><span class="line">    u_char      *m;</span><br><span class="line">    size_t       psize;</span><br><span class="line">    ngx_pool_t  *p, *new;</span><br><span class="line"></span><br><span class="line">    psize = (size_t) (pool-&gt;d.end - (u_char *) pool);</span><br><span class="line"></span><br><span class="line">    // 通过malloc开辟psize大小的内存空间， 即传入的pool的内存大小</span><br><span class="line">    m = ngx_memalign(NGX_POOL_ALIGNMENT, psize, pool-&gt;log);</span><br><span class="line">    if (m == NULL) &#123;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 初始化新开辟的pool</span><br><span class="line">    new = (ngx_pool_t *) m;</span><br><span class="line"></span><br><span class="line">    new-&gt;d.end = m + psize;</span><br><span class="line">    new-&gt;d.next = NULL;</span><br><span class="line">    new-&gt;d.failed = 0;</span><br><span class="line"></span><br><span class="line">    m += sizeof(ngx_pool_data_t);</span><br><span class="line"></span><br><span class="line">    // 设置m的地址，按照 NGX_ALIGNMENT 进行地址对齐</span><br><span class="line">    // m的地址将作为返回地址，故new-&gt;d.last =  m + size，即下一次分配的起始地址</span><br><span class="line">    m = ngx_align_ptr(m, NGX_ALIGNMENT);</span><br><span class="line">    new-&gt;d.last = m + size;</span><br><span class="line"></span><br><span class="line">    // 从current开始，查找 p-&gt;d.next 为NULL的pool节点</span><br><span class="line">    for (p = pool-&gt;current; p-&gt;d.next; p = p-&gt;d.next) &#123;</span><br><span class="line"></span><br><span class="line">        // 如果当前pool节点被查找失败的次数超过了4次(小内存分配失败次数超过4次)，</span><br><span class="line">        // 则直接将current设置为当前节点的next节点</span><br><span class="line">        // 此举是为了提升性能，不用每次都从第一个节点遍历到最后一个节点</span><br><span class="line">        if (p-&gt;d.failed++ &gt; 4) &#123;</span><br><span class="line">            pool-&gt;current = p-&gt;d.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 将新分配的节点添加到next链的尾巴上</span><br><span class="line">    p-&gt;d.next = new;</span><br><span class="line"></span><br><span class="line">    return m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ngx-palloc-large"><a href="#ngx-palloc-large" class="headerlink" title="ngx_palloc_large"></a>ngx_palloc_large</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">// 分配大内存区域</span><br><span class="line">static void *</span><br><span class="line">ngx_palloc_large(ngx_pool_t *pool, size_t size)</span><br><span class="line">&#123;</span><br><span class="line">    void              *p;</span><br><span class="line">    ngx_uint_t         n;</span><br><span class="line">    ngx_pool_large_t  *large;</span><br><span class="line"></span><br><span class="line">    // 通过malloc开辟size大小内存</span><br><span class="line">    p = ngx_alloc(size, pool-&gt;log);</span><br><span class="line">    if (p == NULL) &#123;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    n = 0;</span><br><span class="line"></span><br><span class="line">    // 将开辟后的内存保存在 pool-&gt;large 链上</span><br><span class="line">    for (large = pool-&gt;large; large; large = large-&gt;next) &#123;</span><br><span class="line">        if (large-&gt;alloc == NULL) &#123;</span><br><span class="line">            large-&gt;alloc = p;</span><br><span class="line">            return p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // TODO: 为啥在链表上查找三个节点，没找到就break了</span><br><span class="line">        if (n++ &gt; 3) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 在pool上分配一个 ngx_pool_large_t 的内存大小，用于保存开辟的大内存空间</span><br><span class="line">    large = ngx_palloc_small(pool, sizeof(ngx_pool_large_t), 1);</span><br><span class="line">    if (large == NULL) &#123;</span><br><span class="line">      // 如果分配内存失败，则释放开辟的内存空间</span><br><span class="line">        ngx_free(p);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    large-&gt;alloc = p;</span><br><span class="line">    large-&gt;next = pool-&gt;large;</span><br><span class="line">    pool-&gt;large = large;</span><br><span class="line"></span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ngx-pfree"><a href="#ngx-pfree" class="headerlink" title="ngx_pfree"></a>ngx_pfree</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//  进行内存释放，但是只会释放大内存块</span><br><span class="line">ngx_int_t</span><br><span class="line">ngx_pfree(ngx_pool_t *pool, void *p)</span><br><span class="line">&#123;</span><br><span class="line">    ngx_pool_large_t  *l;</span><br><span class="line"></span><br><span class="line">    // 查找待释放的内存地址是否在large链上</span><br><span class="line">    for (l = pool-&gt;large; l; l = l-&gt;next) &#123;</span><br><span class="line">        if (p == l-&gt;alloc) &#123;</span><br><span class="line">            ngx_log_debug1(NGX_LOG_DEBUG_ALLOC, pool-&gt;log, 0,</span><br><span class="line">                           &quot;free: %p&quot;, l-&gt;alloc);</span><br><span class="line">            // 找到后，只释放分配出来的内存块，并不会将保存该内存块的链表节点释放掉</span><br><span class="line">            ngx_free(l-&gt;alloc);</span><br><span class="line">            l-&gt;alloc = NULL;</span><br><span class="line"></span><br><span class="line">            return NGX_OK;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return NGX_DECLINED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="特殊操作-1"><a href="#特殊操作-1" class="headerlink" title="特殊操作"></a>特殊操作</h3><h4 id="ngx-pool-cleanup-add"><a href="#ngx-pool-cleanup-add" class="headerlink" title="ngx_pool_cleanup_add"></a>ngx_pool_cleanup_add</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// 在cleanup 链上添加一个节点并返回</span><br><span class="line">ngx_pool_cleanup_t *</span><br><span class="line">ngx_pool_cleanup_add(ngx_pool_t *p, size_t size)</span><br><span class="line">&#123;</span><br><span class="line">    ngx_pool_cleanup_t  *c;</span><br><span class="line"></span><br><span class="line">    // 在内存池上分配一个 ngx_pool_cleanup_t 结构体</span><br><span class="line">    c = ngx_palloc(p, sizeof(ngx_pool_cleanup_t));</span><br><span class="line">    if (c == NULL) &#123;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 如果指定的size大小不为0</span><br><span class="line">    if (size) &#123;</span><br><span class="line">        // 通过内存池分配 size 大小的空间</span><br><span class="line">        c-&gt;data = ngx_palloc(p, size);</span><br><span class="line">        if (c-&gt;data == NULL) &#123;</span><br><span class="line">            return NULL;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 指定的size大小为0则，将data域设置为NULL</span><br><span class="line">        c-&gt;data = NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 将新分配的结构体以前插的方式，放在cleanup链的首端</span><br><span class="line">    c-&gt;handler = NULL;</span><br><span class="line">    c-&gt;next = p-&gt;cleanup;</span><br><span class="line"></span><br><span class="line">    p-&gt;cleanup = c;</span><br><span class="line"></span><br><span class="line">    ngx_log_debug1(NGX_LOG_DEBUG_ALLOC, p-&gt;log, 0, &quot;add cleanup: %p&quot;, c);</span><br><span class="line"></span><br><span class="line">    // 返回分配的cleanup结构体地址</span><br><span class="line">    return c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ngx-pool-run-cleanup-file"><a href="#ngx-pool-run-cleanup-file" class="headerlink" title="ngx_pool_run_cleanup_file"></a>ngx_pool_run_cleanup_file</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 执行pool中的文件清理工作</span><br><span class="line">void</span><br><span class="line">ngx_pool_run_cleanup_file(ngx_pool_t *p, ngx_fd_t fd)</span><br><span class="line">&#123;</span><br><span class="line">    ngx_pool_cleanup_t       *c;</span><br><span class="line">    ngx_pool_cleanup_file_t  *cf;</span><br><span class="line"></span><br><span class="line">    // 遍历cleanup链</span><br><span class="line">    for (c = p-&gt;cleanup; c; c = c-&gt;next) &#123;</span><br><span class="line">        // 找到出事函数为 ngx_pool_cleanup_file 的节点</span><br><span class="line">        if (c-&gt;handler == ngx_pool_cleanup_file) &#123;</span><br><span class="line"></span><br><span class="line">            cf = c-&gt;data;</span><br><span class="line"></span><br><span class="line">            // 如果当前节点的文件描述符是指定的fd</span><br><span class="line">            if (cf-&gt;fd == fd) &#123;</span><br><span class="line">                // 执行清理操作</span><br><span class="line">                c-&gt;handler(cf);</span><br><span class="line">                c-&gt;handler = NULL;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ngx-pool-cleanup-file"><a href="#ngx-pool-cleanup-file" class="headerlink" title="ngx_pool_cleanup_file"></a>ngx_pool_cleanup_file</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 文件清理操作处理函数，关闭文件描述符</span><br><span class="line">void</span><br><span class="line">ngx_pool_cleanup_file(void *data)</span><br><span class="line">&#123;</span><br><span class="line">    ngx_pool_cleanup_file_t  *c = data;</span><br><span class="line"></span><br><span class="line">    ngx_log_debug1(NGX_LOG_DEBUG_ALLOC, c-&gt;log, 0, &quot;file cleanup: fd:%d&quot;,</span><br><span class="line">                   c-&gt;fd);</span><br><span class="line"></span><br><span class="line">    if (ngx_close_file(c-&gt;fd) == NGX_FILE_ERROR) &#123;</span><br><span class="line">        ngx_log_error(NGX_LOG_ALERT, c-&gt;log, ngx_errno,</span><br><span class="line">                      ngx_close_file_n &quot; \&quot;%s\&quot; failed&quot;, c-&gt;name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ngx-pool-delete-file"><a href="#ngx-pool-delete-file" class="headerlink" title="ngx_pool_delete_file"></a>ngx_pool_delete_file</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 通过内存池的cleanup链删除文件，以及清理文件描述符</span><br><span class="line">void</span><br><span class="line">ngx_pool_delete_file(void *data)</span><br><span class="line">&#123;</span><br><span class="line">    ngx_pool_cleanup_file_t  *c = data;</span><br><span class="line"></span><br><span class="line">    ngx_err_t  err;</span><br><span class="line"></span><br><span class="line">    ngx_log_debug2(NGX_LOG_DEBUG_ALLOC, c-&gt;log, 0, &quot;file cleanup: fd:%d %s&quot;,</span><br><span class="line">                   c-&gt;fd, c-&gt;name);</span><br><span class="line"></span><br><span class="line">    // 删除文件</span><br><span class="line">    if (ngx_delete_file(c-&gt;name) == NGX_FILE_ERROR) &#123;</span><br><span class="line">        err = ngx_errno;</span><br><span class="line"></span><br><span class="line">        if (err != NGX_ENOENT) &#123;</span><br><span class="line">            ngx_log_error(NGX_LOG_CRIT, c-&gt;log, err,</span><br><span class="line">                          ngx_delete_file_n &quot; \&quot;%s\&quot; failed&quot;, c-&gt;name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 关闭文件描述符</span><br><span class="line">    if (ngx_close_file(c-&gt;fd) == NGX_FILE_ERROR) &#123;</span><br><span class="line">        ngx_log_error(NGX_LOG_ALERT, c-&gt;log, ngx_errno,</span><br><span class="line">                      ngx_close_file_n &quot; \&quot;%s\&quot; failed&quot;, c-&gt;name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li><a href="https://blog.csdn.net/initphp/article/details/50588790">https://blog.csdn.net/initphp/article/details/50588790</a><script src="https://cdn.bootcdn.net/ajax/libs/raphael/2.3.0/raphael.min.js"></script><script src="https://cdn.bootcdn.net/ajax/libs/flowchart/1.17.1/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">st=>start: 开始io_req_memory=>inputoutput: 请求进行内存分配(ngx_palloc、ngx_pcalloc、ngx_pcalloc)cond_mem_size=>condition: 请求内存是否超出节点内存的最大值?sub_small_size=>subroutine: 进行小内存块分配sub_large_size=>subroutine: 进行大内存块分配sub1=>subroutine: 子流程io=>inputoutput: 输入输出e=>end: 结束st->io_req_memory->cond_mem_sizecond_mem_size(no)->sub_small_sizecond_mem_size(yes)->sub_large_sizesub_small_size->esub_large_size->e</textarea><textarea id="flowchart-0-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script></li></ul>]]></content>
    
    
    <summary type="html">Nginx中的内存管理是通过内存池来实现的，nginx的内存池设计得非常巧妙，在我们的日常开发过程中，非常值得借鉴。</summary>
    
    
    
    <category term="nginx" scheme="https://blog.wuhui2356.top/categories/nginx/"/>
    
    
    <category term="nginx" scheme="https://blog.wuhui2356.top/tags/nginx/"/>
    
    <category term="Linux" scheme="https://blog.wuhui2356.top/tags/linux/"/>
    
    <category term="内存池" scheme="https://blog.wuhui2356.top/tags/%E5%86%85%E5%AD%98%E6%B1%A0/"/>
    
  </entry>
  
</feed>
