{"meta":{"title":"Silverlaw's Blog","subtitle":null,"description":null,"author":"silverlaw","url":"https://blog.wuhui2356.top","root":"/"},"pages":[{"title":"Nginx常用配置","date":"2020-02-17T05:43:52.000Z","updated":"2021-12-09T11:49:45.241Z","comments":true,"path":"draft/nginx常用配置.html","permalink":"https://blog.wuhui2356.top/draft/nginx%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE.html","excerpt":"","text":"# Nginx代理配置"},{"title":"DNS服务器配置","date":"2020-02-17T05:43:30.000Z","updated":"2021-12-09T11:49:45.241Z","comments":true,"path":"draft/dns服务器配置.html","permalink":"https://blog.wuhui2356.top/draft/dns%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE.html","excerpt":"","text":""},{"title":"文章分类","date":"2019-08-13T06:39:05.000Z","updated":"2021-12-09T11:49:45.239Z","comments":true,"path":"categories/index.html","permalink":"https://blog.wuhui2356.top/categories/index.html","excerpt":"","text":""},{"title":"","date":"2021-12-09T11:49:45.241Z","updated":"2021-12-09T11:49:45.241Z","comments":true,"path":"draft/idea-vim插件.html","permalink":"https://blog.wuhui2356.top/draft/idea-vim%E6%8F%92%E4%BB%B6.html","excerpt":"","text":"说实话，Intellij IDEA自带的Vim插件真心不错…编程最前线 Today 点击蓝字之后，我们就是好朋友啦 来源：http://hsujee.com 对 Vim 十分熟悉的同学，掌握这个插件会很容易的，在他们的手中才会发挥出该款神器应有的价值。 当然基本的hjkl移动光标和几种常见模式等等基本概念就略过不提了。为了确保只包含常用操作，这里提到的技巧都没有从现成文档里抄，而是凭记忆列出。 1、切换Vim模拟器状态 这个插件允许设置一个快捷键一键开启或关闭，在切换模式时会同时自动切换keymap，十分方便。默认键位是Ctrl+Alt+V，但这个键位覆盖了很常用的“抽取局部变量”功能，建议重设，在setting-&gt;keymap中查找VIM Emulator即可。 由于开启和关闭状态分别使用两套keymap，因此两套都需要设定。可以把两套keymap下的都设为一样的键，也就是用同一个键切换。但个人建议设为不同的键，这样能清楚知道当前处于那种模式中。并且，如果在开启Vim的插入模式下关闭Vim模拟器，下次进入时仍然是插入模式，比较混乱（因为你关闭模拟器就是为了使用默认keymap输入大段代码，重新开启Vim模拟器就是为了使用普通模式下的命令）。 因此建议把Vim keymap中的Exit Insert Mode设为与另一个keymap的Vim Emulator相同的键（也就是进入Vim模拟器的快捷键）。 例如，我使用的设定是： Default keymap -&gt; Vim Emulator : Ctrl+; (用Ctrl+分号开启Vim模拟器） Vim keymap -&gt; Vim Emulator : Ctrl+, (用Ctrl+逗号关闭Vim模拟器） Vim keymap -&gt; Vim Emulator : Ctrl+; (用Ctrl+分号退出插入模式，进入普通模式） 这样，在任何时候只要连按两下ctrl+分号，就能保证必定在Vim模拟器的普通模式中。 2、ScrollOff 参数 启动Intellij后在Vim模拟器下输入命令 : 1set so=5 可以令屏幕滚动时在光标上下方保留5行预览代码（也就是光标会在第5行触发向上滚动，或者在倒数第5行触发向下滚动）。 在代码窗口比较狭小时（例如单步跟踪调试时）非常方便。可惜仅在Vim模拟器开启时有效。 3、行号定位 普通模式下输入 行号G 或 :行号&lt;回车&gt; 都能快速定位到某一行。 区别在于前者在输入行号时屏幕上没有任何提示，后者则在Vim命令输入框中可以看到输入过程。 题外话：Sublime Text 2也是用 :行号 来快速定位到某行，应该是沿用了Vim的习惯。 4、进入修改 进入插入模式的方式有很多，直接选用合适的方式进入插入模式比进入后再用箭头键移动光标要好。常用的有： o - 在当前行下方插入新行并自动缩进 O - 在当前行上方插入新行并自动缩进 （普通模式下的大写字母命令用 shift+字母键 输入，下同） i - 在当前字符左方开始插入字符 a - 在当前字符右方开始插入字符 I - 光标移动到行首并进入插入模式 A - 光标移动到行尾并进入插入模式 s - 删除光标所在字符并进入插入模式 S - 删除光标所在行并进入插入模式 c&lt;范围&gt; - 删除光标所在位置周围某个范围的文本并进入插入模式。关于范围请看第5点，常用的组合有：caw - 删除一个单词包括它后面的空格并开始插入；ciw - 删除一个单词并开始插入；ci” - 删除一个字符串内部文本并开始插入；c$ - 从光标位置删除到行尾并开始插入；ct字符 - 从光标位置删除本行某个字符之前（保留该字符）并开始插入。等等。 C - 删除光标位置到行尾的内容并进入插入模式 (相当于c$) r - 修改光标所在字符，然后返回普通模式 R - 进入覆盖模式 5、范围操作 某些普通模式的动作命令后面可以追加一些表示范围的指令，表示该动作将作用在整个范围上。这类命令常用的有： d&lt;范围&gt; - 删除一定范围内的文本 c&lt;范围&gt; - 删除一定范围内的文本并进入插入模式 y&lt;范围&gt; - 将范围内的文本放入0号和”号注册栏 v&lt;范围&gt; - 选择范围内的文本 =&lt;范围&gt; - 自动缩进范围内的文本 gU&lt;范围&gt; - 将范围内的字符转换为大写 gu&lt;范围&gt; - 将范围内的字符转换为小写 &gt;&lt;范围&gt; - 将范围中的内容缩进一格 &lt;&lt;范围&gt; - 将范围中的内容取消缩进一格 常用的范围指令有： 空格 - 光标所在位置字符。（例如 gU空格 - 将光标位置字符转为大写） 重复某些动作命令 - 光标所在行。（例如dd删除一行，yy复制一行，cc删除一行文本并开始插入，&gt;&gt; 当前行缩进一格，==自动缩进当前行） $ - 从光标位置到行尾 ^ - 从光标位置到行首，不包含缩进空白 0 - 从光标位置到行首，包含缩进空白 gg - 从光标位置到文件开头 G - 从光标位置到文件结尾 % - 从光标位置到另一边匹配的括号 f&lt;字符&gt; - 从光标位置到光标右边某个字符首次出现的位置，包括该字符 F&lt;字符&gt; - 从光标位置到光标左边某个字符首次出现的位置，包括该字符 t&lt;字符&gt; - 从光标位置到光标右边某个字符首次出现的位置，包括该字符 F&lt;字符&gt; - 从光标位置到光标左边某个字符首次出现的位置，包括该字符 /正则表达式 - 从光标位置到下一个匹配正则表达式的位置（跨行） ?正则表达式 - 从光标位置到上一个匹配正则表达式的位置（跨行） aw - 一个单词加一个空格 （a可理解为“一个”，下同） iw - 一个单词 （i可理解为in，下同） a” - 一个字符串包括双引号 i” - 一个字符串内部文本 a&lt; - 一组&lt; &gt;包含的文本，包括&lt; &gt;号本身 同理类推：i&lt;, a[, i[, a(, i( 注意：真正vim中的it范围（一对xml标签内部）在ideaVim中不生效。 用/或?命令查找时，正则表达式默认大小写敏感，如果需要不敏感，可以在正则表达式开始处加上\\c标志。 例如 /\\cabc 可以匹配到 ABC。下面提到的:s命令同样适用。 6、选择文本 在Vim中，选择文本需要进入“可视模式”（Visual Mode），这个名称比较奇怪，它的来由据说是因为在Vim的前身Vi中，选择区域是不可见的。 在Vim中选择区域会高亮显示，因此称为“可视模式”。 v - 进入字符选择模式， V - 进入行选择模式， Ctrl+v - 进入块选择模式。 进入相应模式后移动光标即可选中文本。过程中可按o键令光标在选区两端切换。 在块选择模式中选中多行，然后按I或A后输入文本，再退出插入模式，所输入的文本将自动加入到每一行的开头或结尾。 7、复制粘贴 在Vim模式下，复制粘贴并不直接使用系统的剪贴板，而是使用Vim提供的多个“寄存器”，每个寄存器都以一个字符来表示。 关于寄存器的详细说明可以看这里 http://blah.blogsome.com/2006/04/27/vim_tut_register/ ，这里简单列一些常用的操作技巧 注意，vim使用双引号”来作为选择寄存器的命令，因此下文中的双引号均指在普通模式下按双引号键： a）用y命令将文本存入寄存器后，如果想在别处替换原有内容，可以先用v命令选中原有内容，然后用p命令粘贴。 但第一次粘贴后，默认的寄存器”将被替换为刚刚删除的内容。如果要再次粘贴之前复制的内容，需要使用 “0p 命令组合来复制。 也可以进入插入模式后用 Ctrl+r 0 来复制，例如 ciw&lt;Ctrl+r&gt;0 命令组合将用粘贴内容替换光标处的一个单词，并停留在插入模式。 b）在Windows下，寄存器 + 和 * 都代表系统剪贴板，可以互换使用，选一个顺手的即可。 例如 “+yy 命令组合可将当前行复制到系统剪贴板。ci”&lt;Ctrl+r&gt;* 命令组合则将系统剪贴板的内容替换字符串的内部文本。 c) 寄存器1至9记录之前九次的删除大段文本，每次超过一行的删除操作都会导致这9个寄存器的内容发生位移，最近删除的文本会存入寄存器1。 但只有删除超过1行时才会影响寄存器1至9，行内的删除内容则会被存入寄存器-（减号）。 如果用q命令录制宏时不涉及跨行删除，可以在宏中直接使用这9个寄存器来暂存文本。 （在Vim中，复制内容与录制宏共享同一套寄存器，因此我习惯把字母寄存器留给宏使用） d) 普通模式下小写p把寄存器内容复制到当前位置之后，大写P把寄存器内容复制到当前位置之前。 e) 使用 :regs 命令可以列出当前所有寄存器的内容 8、一些插入模式下的常用快捷键 Ctrl+h - 删除光标左边字符 Ctrl+w - 删除光标左边的单词 Ctrl+y - 复制上方的一个字符 Ctrl+e - 复制下方的一个字符 Ctrl+r 0 - 插入前一次用y命令寄存的内容 Ctrl+r * - 插入系统剪贴板的内容 Ctrl+r &lt;寄存器名称&gt; - 插入指定寄存器的内容 Ctrl+a - 插入前一次插入模式所键入的内容 Ctrl+o - 执行一个普通模式下的命令然后返回插入模式。例如 Ctrl+o A 相当于按 End键， Ctrl+o I相当于按Home键 9、退出插入模式 退出插入模式可以用 ESC 键，但键位太远。其实也可以用 Ctrl+[ 键退出插入模式 。 当然也可以用第1点自定义的Ctrl+;快捷键，但这不是标准vim按键，会养成不良习惯，不建议使用。 10、重复操作 普通模式下按. （小数点）可重复上一次的修改操作 &amp; - 重复上一次的:s替换命令 @@ - 重复上一次执行的宏 11、跳转 Ctrl+] 跳转到当前标识符的定义位置 （相当于在当前光标位置的单词上按住ctrl用鼠标点击） Ctrl+o 回退一步 (go back) Ctrl+i 前进一步 (go forward) `. 跳转到之前修改位置 `` 在前一次跳转位置与当前位置间切换 行号G 或 :行号&lt;回车&gt; 跳转到某一行 gg 跳转到文件开头 G 跳转到文件末尾 H 跳转到屏幕顶端（如果设置了set so=n，则跳转到第n行） L 跳转到屏幕底端（如果设置了set so=n，则跳转到倒数第n行） M 跳转到屏幕中间 f 或 F 跳转到本行某个字符，小写f向右查找，大写F向左查找。用;或,在匹配间切换 t 或 T 跳转到本行某个字符之前，小写t向右查找，大写T向左查找。用;或,在匹配间切换 /正则表达式 跳转到下一个匹配。用n或N在匹配间切换。 ?正则表达式 跳转到上一个匹配。用n或N在匹配间切换。 结合前面第5点，你也许注意到了，在指定范围时，使用跳转命令将指定一个从光标位置到跳转目标的区域。 12、书签 在普通模式下按 m&lt;小写字母&gt; 即可定义书签，按 `&lt;字母&gt; 则可跳转到某个书签的精确位置，按 ‘&lt;字母&gt;可跳转到某个书签所在行的行首（用来录制宏时比较有用）。 最常用的自然是mm, mn, mj, mk, ml这几个顺手的键位。 真正的vim中的全局书签 m&lt;大写字母&gt; 在目前IdeaVim版本中不生效。需要定义全局书签可以使用Idea原本的 F11 + 数字 方式。 13 、文本替换 使用 :s/正则表达式/替换文本/ 可在本行内替换首次出现的匹配 使用 :s/正则表达式/替换文本/g 在本行内替换所有出现的匹配 使用 :%s/正则表达式/替换文本/g 在当前文件内替换所有出现的匹配 在可视模式下选中文本后，使用:’&lt;,’&gt;s/正则表达式/替换文本/g 命令可在选中区域中替换文本。 其中’&lt;,’&gt;部分在可视模式下，按:冒号后自动加入，直接输入s命令即可。但有效区域只能以行为单位。 真正Vim中的 %V 标志在IdeaVim中不生效。 14、代码折叠 zo - 打开折叠 zc - 关闭折叠 15 、宏定义 在IdeaVim中定义宏比Idea自带的宏功能要轻量许多。 按在普通模式下 q&lt;寄存器名称&gt; 即可开始把后续按键序列录制到指定寄存器中（寄存器参考前面第7条）。录制完毕进入普通模式再按q键即可停止录制。 之后用 @&lt;寄存器名称&gt; 即可重放。需要注意的是宏和复制粘贴共用一套寄存器，因此在录制宏时就注意不要把当前宏正在使用的寄存器用来复制了。 寄存器内容是自动保存的，重启Idea仍然生效。但IdeaVim没有导出宏独立保存的功能。因此最好把用来保存宏的寄存器和用来复制粘贴的寄存器分开，不要同一个寄存器有时用来记录宏，有时用来复制粘贴。我的习惯是键盘左手区用来保存一些长期使用的宏（比如说我有一个宏专门用来把pom.xml中的版本号抽取到property区域，原来的位置则改用${property}引用）。 右手区的hjklnm键用来保存一些临时宏。yuiop五个寄存器保留用来复制粘贴。如果录制的宏不涉及删除大段代码，寄存器1至9也可以用来进行复制粘贴。 执行一次宏后，可以用@@命令重复上一次执行的宏。 在Idea中录制宏时，如果触发了代码自动完成，在自动完成列表启动的状态输入的字符不会被记录。因此最好在Setting -&gt; Code Completion -&gt; Autopopup code completion中把延迟设为500ms以上或干脆关掉。在录制宏的过程中避免触发代码自动完成功能。 录制一些长期有效的宏时，开始录制后，最好先用0，^，T, F, $等命令把光标对齐到行首行末或某个特定起始位置（比如说用 F” 跳转到字符串的左边引号），再用一个f或/指令跳转到操作位置，这样的宏就不用必须把光标放在某个特定字符才能使用了。 16、一些常用组合技 全选：ggvG 调换两个字符位置：xp 复制一行：yyp 调换两行位置：ddp 插入模式下到行尾继续输入（相当于End键）：Ctrl+o A 或 Ctrl+[ A 插入模式下到行首继续输入（相当于Home键）：Ctrl+o I 或 Ctrl+[ I 到类定义位置（适用于正确缩进的public，protected类） ：?^p回车 17、一些在目前版本已知没有实现的一些常用Vim功能 如果对Vim不熟悉可以跳过这节。 a）let命令 （没有let命令就无法导出/导入寄存器内容，也就是无法导入宏） b）:g命令 （在文本处理中很有用的一个命令，在编程中倒是不那么常用） c）!命令 （执行shell命令） d）大部分正则表达式标记 （例如 %V， \\v 等等） e) 某些多键命令双击最后一个字符表示作用于当前行。例如在Vim中gUU可以把当前行转换为大写，在IdeaVim中无效，实现同样功能可以先用V命令选中当前行，再用gU转换为大写。 f）关于窗口操作的大部分命令 （Ctrl+w系列命令, :split等） g）所有Vim脚本插件 （不过大部分可以用Idea自身的功能和插件来补偿） 嗯，差点忘了，在普通模式下按u撤销上一个修改（相当于其他IDE的Ctrl+z），按Ctrl+r重做被撤销的修改。"},{"title":"标签","date":"2019-08-13T06:43:11.000Z","updated":"2021-12-09T11:49:45.246Z","comments":true,"path":"tags/index.html","permalink":"https://blog.wuhui2356.top/tags/index.html","excerpt":"","text":""},{"title":"GRUB与GRUB2的区别","date":"2019-08-14T07:48:43.000Z","updated":"2021-12-09T11:49:45.239Z","comments":true,"path":"draft/Linux/grub与grub2的区别.html","permalink":"https://blog.wuhui2356.top/draft/Linux/grub%E4%B8%8Egrub2%E7%9A%84%E5%8C%BA%E5%88%AB.html","excerpt":"什么是GRUB 简单来说GRUB就是电脑开机过后运行的第一个程序，它负责加载操作系统内核并且将当前系统的控制权移交给操作系统内核。","text":"什么是GRUB 简单来说GRUB就是电脑开机过后运行的第一个程序，它负责加载操作系统内核并且将当前系统的控制权移交给操作系统内核。 详细信息参见GRUB的文件。 关于版本 GRUB2是将GRUB完全重构后的版本，所以又将之前版本的GRUB称为GRUB Legacy GRUB Legacy的最后一个版本为: 0.97，即0.97之后的版本均为Grub2,目前GRUB Legacy已经不再做开发了，只进行相关bug的修复，以保证一些旧的系统任然能够使用GRUB Legacy GRUB2的版本是从1.90开始，目前已经到了2.04,它与GRUB Legacy有许多相同的特性，具体的差异见下一小节。 GRUB2与GRUB Legacy的差异未完待续参考文档 项目地址 grub legacy文档 grub2文档 镜像地址"},{"title":"Linux下查看文件的创建时间","date":"2020-02-05T05:45:50.000Z","updated":"2021-12-09T11:49:45.239Z","comments":true,"path":"draft/Linux/linux下查看文件的创建时间.html","permalink":"https://blog.wuhui2356.top/draft/Linux/linux%E4%B8%8B%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6%E7%9A%84%E5%88%9B%E5%BB%BA%E6%97%B6%E9%97%B4.html","excerpt":"","text":""},{"title":"Linux 下扩展磁盘分区","date":"2019-10-29T06:00:35.000Z","updated":"2021-12-09T11:49:45.239Z","comments":true,"path":"draft/Linux/linux-扩展磁盘分区.html","permalink":"https://blog.wuhui2356.top/draft/Linux/linux-%E6%89%A9%E5%B1%95%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA.html","excerpt":"","text":"扩展指定的磁盘分区首先查看当前系统的磁盘和分区大小12345678// 查看所有的磁盘和分区大小[root@localhost /]# lsblkNAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINTsda 8:0 0 29.8G 0 disk └─sda1 8:1 0 23.4G 0 part /sdb 8:16 0 3.7T 0 disk ├─sdb1 8:17 0 32G 0 part └─sdb2 8:18 0 3.6T 0 part 12345678910// 查看当前文件系统的使用量[root@localhost /]# df -h文件系统 容量 已用 可用 已用% 挂载点/dev/root 19G 18G 0 100% /devtmpfs 16G 0 16G 0% /devtmpfs 16G 0 16G 0% /dev/shmtmpfs 16G 16M 16G 1% /runtmpfs 5.0M 0 5.0M 0% /run/locktmpfs 16G 0 16G 0% /sys/fs/cgrouptmpfs 3.1G 0 3.1G 0% /run/user/0"},{"title":"syslog协议","date":"2019-08-15T09:38:00.000Z","updated":"2021-12-09T11:49:45.239Z","comments":true,"path":"draft/Linux/syslog协议.html","permalink":"https://blog.wuhui2356.top/draft/Linux/syslog%E5%8D%8F%E8%AE%AE.html","excerpt":"简介 syslog协议属于一种主从式协议，通常被用于信息系统管理及信息安全审核。虽然它有不少缺陷，但仍获得相当多的设备及各种平台的接收端支持。因此syslog能被用来将来自许多不同类型系统的日志记录集成到集中的存储库中。","text":"简介 syslog协议属于一种主从式协议，通常被用于信息系统管理及信息安全审核。虽然它有不少缺陷，但仍获得相当多的设备及各种平台的接收端支持。因此syslog能被用来将来自许多不同类型系统的日志记录集成到集中的存储库中。 协议内容 syslog格式为一个长字符串，整个数据报分为三个部分：PRI、HEADER、MSG PRI: 只能为3、4、5个字符，并且以小于符号开始，以大于符号结束，中间为一个1到3位的数字 HEADER: 由TimeStamp与HostName组成。HEADER部分紧跟PRI，中间没有空格。TimeStamp与HostName之间间隔一个空格。HostName后面紧跟一个空格。 TimeStamp: 字段使用local time，格式为：Mmm dd hh:mm:ss Mmm: 是英语月份的单词缩写，例如：Jan, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Oct, Nov, Dec dd: 某个月的多少号，固定宽度2个字符，不足两个字符在数字前面用空格填充。 hh:mm:ss: 本地时间 hh: 24时制的小时，在00-23之间 mm和ss： 分和秒，在00-59之间 HostName: 该字段为主机的hostname。该字段后面紧跟一个空格 MSG: 该字段又两部分组成： TAG和CONTENT TAG: 该字段的值为产生日志的程序名，即推送日志到外部系统的程序名（不超过32个字符）。TAG后面紧跟一个用中括号包含着的pid,即[pid],并且再追加一个:,pid为该推送程序的进程号 CONTENT: 该字段为具体的日志内容 综上，整个数据报为：1&lt;xxx&gt;Mmm dd hh:mm:ss hostname tag[pid]: xxxxxxxxx rsyslog服务器配置安装syslog服务1sudo yum install rsyslog -y 修改配置文件123456789$ModLoad imudp$UDPServerRun 514$ModLoad imtcp$InputTCPServerRun 514$template RemoteLogs,&quot;/var/log/%HOSTNAME%/%PROGRAMNAME%.log&quot; **.* ?RemoteLogs&amp; ~ 启动rsyslog服务生效1systemctl restart rsyslog 参考文献"},{"title":"主引导记录MBR","date":"2019-08-14T07:38:26.000Z","updated":"2021-12-09T11:49:45.239Z","comments":true,"path":"draft/Linux/主引导记录MBR.html","permalink":"https://blog.wuhui2356.top/draft/Linux/%E4%B8%BB%E5%BC%95%E5%AF%BC%E8%AE%B0%E5%BD%95MBR.html","excerpt":"","text":"什么是MBR 主引导记录（Master Boot Record，缩写：MBR），又叫做主引导扇区，是计算机开机后访问硬盘时所必须要读取的首个扇区，它在硬盘上的三维地址为（柱面，磁头，扇区）＝（0，0，1）。参见维基百科 MBR说明结构 主引导扇区记录着硬盘本身的相关信息以及硬盘各个分区的大小及位置信息，是数据信息的重要入口,它位于硬盘的第一个扇区，即硬盘的前512个字节。这512字节又分为三个部分：启动代码、硬盘分区表、结束标志字。 启动代码： 硬盘的第 1-446 字节 (共446字节) 硬盘分区表: 硬盘的第 447-510 字节 (共64字节) 结束标志字: 硬盘的第 511-512 字节 (共2字节)，为 0x55 和 0xAA 启动代码 主引导记录最开头是第一阶段引导代码。其中的硬盘引导程序的主要作用是检查分区表是否正确并且在系统硬件完成自检以后将控制权交给硬盘上的引导程序（如GNU GRUB）。它不依赖任何操作系统，而且启动代码也是可以改变的，从而能够实现多系统引导。 硬盘分区表 硬盘分区表共64字节，又分为4项,每项16字节。故我们在对系统进行分区时，最多只能划分4个主分区或者3个主分区+1个扩展分区。 未完待续参考文档 https://wiki.osdev.org/MBR_(x86) https://en.wikipedia.org/wiki/Master_boot_record"},{"title":"树莓派常用配置","date":"2020-02-12T04:46:00.000Z","updated":"2021-12-09T11:49:45.239Z","comments":true,"path":"draft/Linux/树莓派常用配置.html","permalink":"https://blog.wuhui2356.top/draft/Linux/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE.html","excerpt":"","text":"基本信息 型号: 3B+ 操作系统: UBUNTU 18.04.4 LTS (Bionic Beaver) 网络配置（netplan） 配置文件路径: ​ /etc/netplan/50-cloud-init.yaml 配置文件内容: 12345678910# 配置静态IPnetwork: ethernets: enp0s3: dhcp4: false addresses: [192.168.0.201/24] gateway4: 192.168.0.1 nameservers: addresses: [192.168.0.1, 8.8.8.8] version: 2 应用配置: 1sudo netplan --debug apply"},{"title":"常用工具国内镜像源配置","date":"2020-02-03T06:32:25.000Z","updated":"2021-12-09T11:49:45.241Z","comments":true,"path":"draft/其他/常用工具国内镜像源配置.html","permalink":"https://blog.wuhui2356.top/draft/%E5%85%B6%E4%BB%96/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E5%9B%BD%E5%86%85%E9%95%9C%E5%83%8F%E6%BA%90%E9%85%8D%E7%BD%AE.html","excerpt":"","text":"前言我们的日常开发过程中会使用到很多的第三方工具，但是由于大部分工具的源（扩展包、库）都在国外，在线下载非常慢，耗时久。但是一般情况下，国内的大厂或者一些高校等都会对常用的工具免费提供对应的镜像仓库，故在我们的开发过程中直接使用国内的镜像网站，即可加速下载，节约大量的时间。 npm 国内镜像源配置NPM（Node Package Manager），是NodeJs的模块依赖管理工具。一般情况下使用淘宝的源即可，可以直接执行以下命令进行配置： 12345// 临时配置npm --registry https://registry.npm.taobao.org install express// 持久化配置npm config set registry https://registry.npm.taobao.org 配置完成后可以执行以下命令查看当前使用的源： 123npm info expressnpm config get registry Golang 代理配置Go（又称 Golang）是 Google 的 Robert Griesemer，Rob Pike 及 Ken Thompson 开发的一种静态强类型、编译型语言。Go 语言语法与 C相近，但功能上有：内存安全，GC(垃圾回收），结构形态及 CSP-style 并发计算。需要下载除SDK中自带的库时，可以直接使用以下代理地址： 12https://goproxy.cnhttps://goproxy.io 直接添加以下环境变量即可： 12export GO111MODULE=onexport GOPROXY=https://goproxy.cn,direct 在GoLand中进行如下图所示的设置即可： 然后通过以下命令下载对应的包即可： 1go get &lt;package&gt; 参考链接： GoProxy中国 maven 国内镜像源配置"},{"title":"自定义CentOS7安装镜像","date":"2020-02-09T10:30:12.000Z","updated":"2021-12-09T11:49:45.241Z","comments":true,"path":"draft/Linux/自定义centos7安装镜像.html","permalink":"https://blog.wuhui2356.top/draft/Linux/%E8%87%AA%E5%AE%9A%E4%B9%89centos7%E5%AE%89%E8%A3%85%E9%95%9C%E5%83%8F.html","excerpt":"","text":"前言Anaconda是Red Hat和Fedora(红帽系,包括CentOS等)的安装程序,在Red Hat 7和Fedora 17之后对Anaconda进行了很大的优化,主要是加强用户的自定义能力.目前可以通过编写插件的方式来对安装程序和图形界面进行修改和扩展.本文主要阐述如何对以下内容的修改: 引导菜单 图形界面 扩展安装功能 注意: 本文只针对Red Hat 7 Fedora 17 CentOS 7及以上的操作系统 准备工作本文的实践过程以CentOS7.6的minimal安装镜像为基础,在此基础上进行修改,对安装功能进行自定义. 准备环境: CentOS7.6 虚拟机一台,默认已经安装完毕,下文的所有操作未特别说明,均在改虚拟机中进行. 下载镜像 镜像下载地址: http://vault.centos.org/7.6.1810/isos/x86_64/CentOS-7-x86_64-Minimal-1810.iso,可以通过一下命令进行下载: 1wget http://vault.centos.org/7.6.1810/isos/x86_64/CentOS-7-x86_64-Minimal-1810.iso"},{"title":"逻辑卷LVM相关操作","date":"2019-08-15T01:30:30.000Z","updated":"2021-12-09T11:49:45.241Z","comments":true,"path":"draft/Linux/逻辑卷LVM相关的操作.html","permalink":"https://blog.wuhui2356.top/draft/Linux/%E9%80%BB%E8%BE%91%E5%8D%B7LVM%E7%9B%B8%E5%85%B3%E7%9A%84%E6%93%8D%E4%BD%9C.html","excerpt":"什么是逻辑卷 逻辑卷（lv）是将几个磁盘分区或者块设备(pv，pv的id必须是8e的，pv可以位于不同的磁盘分区里，pv大小可以不一)组织起来形成一个大的扩展分区（vg,卷组，一个vg至少要包含一个pv。），该扩展分区不能直接用，需要将其划分成逻辑卷（lv）才能使用，lv可以格式化成不同的文件系统，挂载后直接使用。","text":"什么是逻辑卷 逻辑卷（lv）是将几个磁盘分区或者块设备(pv，pv的id必须是8e的，pv可以位于不同的磁盘分区里，pv大小可以不一)组织起来形成一个大的扩展分区（vg,卷组，一个vg至少要包含一个pv。），该扩展分区不能直接用，需要将其划分成逻辑卷（lv）才能使用，lv可以格式化成不同的文件系统，挂载后直接使用。 lv的扩展和缩减是不会影响原有数据的，但逻辑卷缩减的风险大于逻辑卷扩展的风险。 逻辑卷可以支持快照功能。 相关术语 物理卷（PV, Physical Volume） 物理卷就是指磁盘,磁盘分区或从逻辑上和磁盘分区具有同样功能的设备(如RAID)，是LVM的基本存储逻辑块，但和基本的物理存储介质（如分区、磁盘等）比较，却包含有和LVM相关的管理参数。当前LVM允许你在每个物理卷上保存这个物理卷的0至2份元数据拷贝.默认为1,保存在设备的开始处.为2时,在设备结束处保存第二份备份. 卷组（VG, Volume Group） LVM卷组类似于非LVM系统中的物理硬盘，其由物理卷组成。能在卷组上创建一个或多个“LVM分区”（逻辑卷），LVM卷组由一个或多个物理卷组成。 逻辑卷（LV, Logical Volume） LVM的逻辑卷类似于非LVM系统中的硬盘分区，在逻辑卷之上能建立文件系统(比如/home或/usr等)。 线性逻辑卷 (Linear Volumes) 一个线性逻辑卷聚合多个物理卷成为一个逻辑卷.比如,如果你有两个60GB硬盘,你能生成120GB的逻辑卷. 条块化的逻辑卷(Striped Logical Volumes) 当你写数据到此逻辑卷中时,文件系统能将数据放置到多个物理卷中.对于大量连接读写操作,他能改善数据I/O效率. 映像的逻辑卷(Mirrored Logical Volumes) 映像在不同的设备上保存一致的数据.数据同时被写入原设备及映像设备.他提供设备之间的容错。 快照卷(Snapshot Volumes) 快照卷提供在特定瞬间的一个设备虚拟映像，当快照开始时，他复制一份对当前数据区域的改动，由于他优先执行这些改动，所以他能重构当前设备的状态。 参考: https://www.cnblogs.com/shxdyz/articles/7834980.html 查看逻辑卷信息查看LV lvscan123[root@localhost ~]# lvscan ACTIVE &#x27;/dev/VG_BASTION/LV_SWAP&#x27; [2.00 GiB] inherit ACTIVE &#x27;/dev/VG_BASTION/LV_DATA&#x27; [&lt;57.98 GiB] inherit 查看VG vgscan123[root@localhost ~]# vgscan Reading volume groups from cache. Found volume group &quot;VG_BASTION&quot; using metadata type lvm2 查看PV pvscan12345[root@localhost ~]# pvscan PV /dev/sdb1 VG VG_BASTION lvm2 [19.99 GiB / 0 free] PV /dev/sdc1 VG VG_BASTION lvm2 [19.99 GiB / 0 free] PV /dev/sdd1 VG VG_BASTION lvm2 [19.99 GiB / 0 free] Total: 3 [&lt;59.98 GiB] / in use: 3 [&lt;59.98 GiB] / in no VG: 0 [0 ] 创建逻辑卷说明 再创建逻辑卷时，应当先创建物理卷(pv)，再创建卷组(vg)，最后再创建逻辑卷(lv) 创建PV pvcreate12345678pvcreate &lt;device&gt;// device: 要创建物理卷的设备路径示例:[root@centos6 bash]# pvcreate /dev/sda1 Physical volume &quot;/dev/sda1&quot; successfully created 创建VG vgcreate123456789vgcreate &lt;vg_name&gt; &lt;pv list&gt;// vg_name: 卷组名// device list: 要添加到卷组的物理卷pv列表示例:[root@centos6 bash]# vgcreate vg_bastion /dev/sda1 /dev/sdc1 Volume group &quot;vg_bastion&quot; successfully created 修改卷组属性 vgchange 激活卷组: vgchange -ay vg_bastion 创建LV lvcreate1234567891011121314lvcreate -n &lt;lv_name&gt; -L &lt;size&gt; &lt;vg_name&gt; -ylvcreate -n &lt;lv_name&gt; -l &lt;size&gt; &lt;vg_name&gt; -y// -L: 指定大小(--size LogicalVolumeSize[bBsSkKmMgGtTpPeE])// -l: 可以指定百分比(--extents LogicalExtentsNumber[%&#123;VG|FREE|ORIGIN&#125;]),如 100%FREE// lv_name: 逻辑卷名// size： 创建的卷大小// vg_name: 卷组名示例: lvcreate -n &quot;lv_swap&quot; -L &quot;2GiB&quot; &quot;vg_bastion&quot; -y lvcreate -n &quot;lv_data&quot; -l &quot;100%FREE&quot; &quot;vg_bastion&quot; -y 删除逻辑卷说明 在删除逻辑卷之前，应当先卸载掉已经被挂载的分区，然后再进行逻辑卷的删除。 在卸载分区时，如果遇到当前分区正在被使用，无法进行卸载的情况，可以借助lsof命令找到正在占用挂载点的进程，然后将其kill掉，再进行卸载在操作。 逻辑卷的删除顺序与创建顺序相反，首先删除逻辑卷(lv)，然后删除卷组(vg)，最后删除物理卷(pv) 删除LV lvremove12[root@localhost ~]# lvremove /dev/VG_BASTION/LV_SWAP -f -y Logical volume &quot;LV_SWAP&quot; successfully removed 删除VG vgremove12[root@localhost ~]# vgremove VG_BASTION -f -y Volume group &quot;VG_BASTION&quot; successfully removed 删除PV pvremove12[root@localhost ~]# pvremove /dev/sdb1 -f -y Labels on physical volume &quot;/dev/sdb1&quot; successfully wiped. 磁盘分区创建磁盘分区 创建分区表,采用 msdos(MBR)或者GPT GPT分区表: parted -s /dev/sdd mklabel gpt MBR分区表: parted -s /dev/sdd mklabel msdos 创建主分区: 123456789101112parted -s &lt;device&gt; mkpart &lt;part-type&gt; [fs-type] start end// deice: 指定磁盘设备// part-type: 只能为 primary(主分区)、logical(逻辑分区)、extended(扩展分区)// fs-type: 非必填参数,可以为: &quot;btrfs&quot;, &quot;ext2&quot;, &quot;ext3&quot;, &quot;ext4&quot;, &quot;fat16&quot;, &quot;fat32&quot;, &quot;hfs&quot;, &quot;hfs+&quot;, &quot;linux-swap&quot;, &quot;ntfs&quot;, &quot;reiserfs&quot;, or &quot;xfs&quot;// start: 指定分区开始位置，默认为磁盘起始位置// end: 指定分区结束位置,默认为磁盘结束位置示例: parted -s /dev/sdd mkpart primary 4MiB 100% // 在 /dev/sdd 上创建一个主分区，从4MiB的位置开始，到磁盘末尾结束 // 即整个分区大小为 磁盘大小-4MiB 修改分区表状态12345678910parted -s &lt;device&gt; toggle &lt;partition_number&gt; &lt;status&gt;// device: 指定磁盘设备// partition_number: 该磁盘设备上的第几个分区// status: 转换后的状态(raid|lvm)示例: parted -s /dev/sdd toggle 1 &quot;lvm&quot; // 将 /dev/sdd 上的第一个分区标记为 lvm 删除磁盘分区 可以通过parted删除指定的某个分区: parted -s /dev/sdc rm 1123456789parted -s &lt;device&gt; rm &lt;partition_number&gt;// device: 指定磁盘设备// partition_number: 该磁盘设备上的第几个分区示例: parted -s /dev/sdc rm 1 // 删除 /dev/sdc 上的第一个分区 一般情况下，如果要摧毁整个磁盘分区，那么只需要将磁盘首部的分区表摧毁掉就行了，所以，可以直接采用dd命令: dd if=/dev/zero of=/dev/sdd bs=16MiB count=1 磁盘格式化 制作交换分区: mkswap123456789mkswap -f -L &lt;label&gt; &lt;device&gt;// device: 指定磁盘设备// label: 指定交换分区的标签label示例： mkswap -f -L label_swap /dev/vg_bastion/lv_swap 格式化: mkfs12345678910111213mkfs.&lt;fs&gt; -L &lt;label&gt; &lt;device&gt;// fs: 文件系统格式// device: 指定磁盘设备// label: 指定交换分区的标签label示例: mkfs.xfs -L label_data /dev/vg_bastion/lv_data mkfs.ext4 -L label_data /dev/vg_bastion/lv_data mkfs -t xfs -L label_data /dev/vg_bastion/lv_data mkfs -t ext4 -L label_data /dev/vg_bastion/lv_data 数据无价，操作需谨慎参考文献 https://blog.csdn.net/solaraceboy/article/details/78539233 https://www.cnblogs.com/shxdyz/articles/7834980.html"},{"title":"C++动态加载lib的插件机制实现","date":"2020-01-03T13:44:25.000Z","updated":"2021-12-09T11:49:45.241Z","comments":true,"path":"draft/编程基础/C++动态加载DLL的插件机制实现.html","permalink":"https://blog.wuhui2356.top/draft/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/C++%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BDDLL%E7%9A%84%E6%8F%92%E4%BB%B6%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0.html","excerpt":"","text":"什么是插件 插件是一种非常强大的程序动态加载机制，能够在对已有程序不做任何改动的情况下，对程序进行扩展。"},{"title":"golang从入门到放弃","date":"2020-02-03T14:36:07.000Z","updated":"2021-12-09T11:49:45.241Z","comments":true,"path":"draft/编程基础/golang从入门到放弃.html","permalink":"https://blog.wuhui2356.top/draft/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/golang%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83.html","excerpt":"","text":"前言Go（又称 Golang）是 Google 的 Robert Griesemer，Rob Pike 及 Ken Thompson 开发的一种静态强类型、编译型语言。Go 语言语法与 C相近，但功能上有：内存安全，GC(垃圾回收），结构形态及 CSP-style 并发计算。 包管理 Go Modgo modules 是 golang 1.11 添加的新特性(默认关闭)，在1.11之前的版本中，针对于第三方库的引用，直接讲对应的库文件放在GOPATH环境变量下即可，故通常会设置一个系统全局的GOPATH以及一个或者多个工程的GOPATH。但是在引入了go modules以后，就直接通过go.mod文件(该文件不能存在与GOPATH环境变量中)来进行第三方库的管理，同时需要设置环境变量GO111MODULE=on来开启go modules， 通过go get命令下载的所有库都会自动托管到go.mod文件中。 注意： goland中会遇到无法解析import进来的包，但是程序又能正常运行的情况，该种现象的出现就是两种包管理方式混乱了，直接采用go.mod文件这种方式对第三方包进行管理即可。如果包下载慢或者部分包无法下载的情况，参考另一篇文章设置代理即可。"}],"posts":[{"title":"C++动态加载lib的插件机制实现","slug":"编程基础/C++动态加载DLL的插件机制实现","date":"2020-01-03T13:44:25.000Z","updated":"2021-12-09T11:49:45.239Z","comments":true,"path":"2020/01/03/编程基础/C++动态加载DLL的插件机制实现/","link":"","permalink":"https://blog.wuhui2356.top/2020/01/03/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/C++%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BDDLL%E7%9A%84%E6%8F%92%E4%BB%B6%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"什么是插件插件，想必大家应该是陌生了吧，什么Vim、VS code、JetBrains全家桶啊都支持插件，但是这背后是如何实现的呢？今天我们就来好好掰扯掰扯。首先我们可以先来看看对插件比较官方的定义，还麻烦大家挪挪步百度百科关于插件的定义，但是这些都不重要，重要的是我们要如何来实现插件机制，如何实现在对已有程序不做任何修改的情况下，对程序功能的扩展。。。 需求大家先把菜刀准备好啊，需求要来了，贴个代码先： 12345int main(int argc, char *argv[])&#123; printf(&quot;Hello world.\\n&quot;); return 0;&#125; 没错，这就是一个简单的Hello world，但是呢, 产品汪A: 我这个项目要先打印一行123456再显示Hello world 产品汪B: 我这个项目要先先打印Hello world再打印123456 产品汪C: 我这个不显示Hello world，只打印123456 产品汪……. 这个栗子比较简单，一般我们遇到的需求比这个复杂多了，动不动就是某某功能里面，我要加一个什么什么逻辑，所以针对不同的需求，就要编译N个版本的exe进行交付，然后又要挨着全部测试N遍吗？不，插件机制，就能很好的帮我们解决这个问题。 引入插件后的程序结构 整个插件框架大概是这个样子的，最主要的编码工作是在PluginManager这个类里面，其他两个都是约定的接口，但是针对我们上面的需求，就是下面这个样子的： 其中IPrintEvent是定义的一个打印事件，而PrintPlugin则是具体的打印实现过程，即直接将PrintPlugin的打印实现直接变成so，然后由程序启动后进行动态加载即可。 废话就不多说了，是骡子是马，咱拉出来溜溜，首先贴个图，便于直观的理解。","categories":[{"name":"编程基础","slug":"编程基础","permalink":"https://blog.wuhui2356.top/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"C++","slug":"c","permalink":"https://blog.wuhui2356.top/tags/c/"},{"name":"插件","slug":"插件","permalink":"https://blog.wuhui2356.top/tags/%E6%8F%92%E4%BB%B6/"}]}],"categories":[{"name":"编程基础","slug":"编程基础","permalink":"https://blog.wuhui2356.top/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"C++","slug":"c","permalink":"https://blog.wuhui2356.top/tags/c/"},{"name":"插件","slug":"插件","permalink":"https://blog.wuhui2356.top/tags/%E6%8F%92%E4%BB%B6/"}]}