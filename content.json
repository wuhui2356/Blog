{"meta":{"title":"wuhui2356's Blog","subtitle":null,"description":null,"author":"wuhui2356","url":"https://blog.wuhui2356.top","root":"/"},"pages":[{"title":"文章分类","date":"2019-08-13T06:39:05.000Z","updated":"2021-12-10T04:23:02.808Z","comments":true,"path":"categories/index.html","permalink":"https://blog.wuhui2356.top/categories/index.html","excerpt":"","text":""},{"title":"DNS服务器配置","date":"2020-02-17T05:43:30.000Z","updated":"2021-12-10T04:23:02.809Z","comments":true,"path":"draft/dns服务器配置.html","permalink":"https://blog.wuhui2356.top/draft/dns%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE.html","excerpt":"","text":""},{"title":"","date":"2021-12-10T04:23:02.809Z","updated":"2021-12-10T04:23:02.809Z","comments":true,"path":"draft/idea-vim插件.html","permalink":"https://blog.wuhui2356.top/draft/idea-vim%E6%8F%92%E4%BB%B6.html","excerpt":"","text":"说实话，Intellij IDEA自带的Vim插件真心不错…编程最前线 Today 点击蓝字之后，我们就是好朋友啦 来源：http://hsujee.com 对 Vim 十分熟悉的同学，掌握这个插件会很容易的，在他们的手中才会发挥出该款神器应有的价值。 当然基本的hjkl移动光标和几种常见模式等等基本概念就略过不提了。为了确保只包含常用操作，这里提到的技巧都没有从现成文档里抄，而是凭记忆列出。 1、切换Vim模拟器状态 这个插件允许设置一个快捷键一键开启或关闭，在切换模式时会同时自动切换keymap，十分方便。默认键位是Ctrl+Alt+V，但这个键位覆盖了很常用的“抽取局部变量”功能，建议重设，在setting-&gt;keymap中查找VIM Emulator即可。 由于开启和关闭状态分别使用两套keymap，因此两套都需要设定。可以把两套keymap下的都设为一样的键，也就是用同一个键切换。但个人建议设为不同的键，这样能清楚知道当前处于那种模式中。并且，如果在开启Vim的插入模式下关闭Vim模拟器，下次进入时仍然是插入模式，比较混乱（因为你关闭模拟器就是为了使用默认keymap输入大段代码，重新开启Vim模拟器就是为了使用普通模式下的命令）。 因此建议把Vim keymap中的Exit Insert Mode设为与另一个keymap的Vim Emulator相同的键（也就是进入Vim模拟器的快捷键）。 例如，我使用的设定是： Default keymap -&gt; Vim Emulator : Ctrl+; (用Ctrl+分号开启Vim模拟器） Vim keymap -&gt; Vim Emulator : Ctrl+, (用Ctrl+逗号关闭Vim模拟器） Vim keymap -&gt; Vim Emulator : Ctrl+; (用Ctrl+分号退出插入模式，进入普通模式） 这样，在任何时候只要连按两下ctrl+分号，就能保证必定在Vim模拟器的普通模式中。 2、ScrollOff 参数 启动Intellij后在Vim模拟器下输入命令 : - 1set so=5 可以令屏幕滚动时在光标上下方保留5行预览代码（也就是光标会在第5行触发向上滚动，或者在倒数第5行触发向下滚动）。 在代码窗口比较狭小时（例如单步跟踪调试时）非常方便。可惜仅在Vim模拟器开启时有效。 3、行号定位 普通模式下输入 行号G 或 :行号&lt;回车&gt; 都能快速定位到某一行。 区别在于前者在输入行号时屏幕上没有任何提示，后者则在Vim命令输入框中可以看到输入过程。 题外话：Sublime Text 2也是用 :行号 来快速定位到某行，应该是沿用了Vim的习惯。 4、进入修改 进入插入模式的方式有很多，直接选用合适的方式进入插入模式比进入后再用箭头键移动光标要好。常用的有： o - 在当前行下方插入新行并自动缩进 O - 在当前行上方插入新行并自动缩进 （普通模式下的大写字母命令用 shift+字母键 输入，下同） i - 在当前字符左方开始插入字符 a - 在当前字符右方开始插入字符 I - 光标移动到行首并进入插入模式 A - 光标移动到行尾并进入插入模式 s - 删除光标所在字符并进入插入模式 S - 删除光标所在行并进入插入模式 c&lt;范围&gt; - 删除光标所在位置周围某个范围的文本并进入插入模式。关于范围请看第5点，常用的组合有：caw - 删除一个单词包括它后面的空格并开始插入；ciw - 删除一个单词并开始插入；ci” - 删除一个字符串内部文本并开始插入；c$ - 从光标位置删除到行尾并开始插入；ct字符 - 从光标位置删除本行某个字符之前（保留该字符）并开始插入。等等。 C - 删除光标位置到行尾的内容并进入插入模式 (相当于c$) r - 修改光标所在字符，然后返回普通模式 R - 进入覆盖模式 5、范围操作 某些普通模式的动作命令后面可以追加一些表示范围的指令，表示该动作将作用在整个范围上。这类命令常用的有： d&lt;范围&gt; - 删除一定范围内的文本 c&lt;范围&gt; - 删除一定范围内的文本并进入插入模式 y&lt;范围&gt; - 将范围内的文本放入0号和”号注册栏 v&lt;范围&gt; - 选择范围内的文本 &#x3D;&lt;范围&gt; - 自动缩进范围内的文本 gU&lt;范围&gt; - 将范围内的字符转换为大写 gu&lt;范围&gt; - 将范围内的字符转换为小写 &gt;&lt;范围&gt; - 将范围中的内容缩进一格 &lt;&lt;范围&gt; - 将范围中的内容取消缩进一格 常用的范围指令有： 空格 - 光标所在位置字符。（例如 gU空格 - 将光标位置字符转为大写） 重复某些动作命令 - 光标所在行。（例如dd删除一行，yy复制一行，cc删除一行文本并开始插入，&gt;&gt; 当前行缩进一格，&#x3D;&#x3D;自动缩进当前行） $ - 从光标位置到行尾 ^ - 从光标位置到行首，不包含缩进空白 0 - 从光标位置到行首，包含缩进空白 gg - 从光标位置到文件开头 G - 从光标位置到文件结尾 % - 从光标位置到另一边匹配的括号 f&lt;字符&gt; - 从光标位置到光标右边某个字符首次出现的位置，包括该字符 F&lt;字符&gt; - 从光标位置到光标左边某个字符首次出现的位置，包括该字符 t&lt;字符&gt; - 从光标位置到光标右边某个字符首次出现的位置，包括该字符 F&lt;字符&gt; - 从光标位置到光标左边某个字符首次出现的位置，包括该字符 &#x2F;正则表达式 - 从光标位置到下一个匹配正则表达式的位置（跨行） ?正则表达式 - 从光标位置到上一个匹配正则表达式的位置（跨行） aw - 一个单词加一个空格 （a可理解为“一个”，下同） iw - 一个单词 （i可理解为in，下同） a” - 一个字符串包括双引号 i” - 一个字符串内部文本 a&lt; - 一组&lt; &gt;包含的文本，包括&lt; &gt;号本身 同理类推：i&lt;, a[, i[, a(, i( 注意：真正vim中的it范围（一对xml标签内部）在ideaVim中不生效。 用&#x2F;或?命令查找时，正则表达式默认大小写敏感，如果需要不敏感，可以在正则表达式开始处加上\\c标志。 例如 &#x2F;\\cabc 可以匹配到 ABC。下面提到的:s命令同样适用。 6、选择文本 在Vim中，选择文本需要进入“可视模式”（Visual Mode），这个名称比较奇怪，它的来由据说是因为在Vim的前身Vi中，选择区域是不可见的。 在Vim中选择区域会高亮显示，因此称为“可视模式”。 v - 进入字符选择模式， V - 进入行选择模式， Ctrl+v - 进入块选择模式。 进入相应模式后移动光标即可选中文本。过程中可按o键令光标在选区两端切换。 在块选择模式中选中多行，然后按I或A后输入文本，再退出插入模式，所输入的文本将自动加入到每一行的开头或结尾。 7、复制粘贴 在Vim模式下，复制粘贴并不直接使用系统的剪贴板，而是使用Vim提供的多个“寄存器”，每个寄存器都以一个字符来表示。 关于寄存器的详细说明可以看这里 http://blah.blogsome.com/2006/04/27/vim_tut_register/ ，这里简单列一些常用的操作技巧 注意，vim使用双引号”来作为选择寄存器的命令，因此下文中的双引号均指在普通模式下按双引号键： a）用y命令将文本存入寄存器后，如果想在别处替换原有内容，可以先用v命令选中原有内容，然后用p命令粘贴。 但第一次粘贴后，默认的寄存器”将被替换为刚刚删除的内容。如果要再次粘贴之前复制的内容，需要使用 “0p 命令组合来复制。 也可以进入插入模式后用 Ctrl+r 0 来复制，例如 ciw&lt;Ctrl+r&gt;0 命令组合将用粘贴内容替换光标处的一个单词，并停留在插入模式。 b）在Windows下，寄存器 + 和 * 都代表系统剪贴板，可以互换使用，选一个顺手的即可。 例如 “+yy 命令组合可将当前行复制到系统剪贴板。ci”&lt;Ctrl+r&gt;* 命令组合则将系统剪贴板的内容替换字符串的内部文本。 c) 寄存器1至9记录之前九次的删除大段文本，每次超过一行的删除操作都会导致这9个寄存器的内容发生位移，最近删除的文本会存入寄存器1。 但只有删除超过1行时才会影响寄存器1至9，行内的删除内容则会被存入寄存器-（减号）。 如果用q命令录制宏时不涉及跨行删除，可以在宏中直接使用这9个寄存器来暂存文本。 （在Vim中，复制内容与录制宏共享同一套寄存器，因此我习惯把字母寄存器留给宏使用） d) 普通模式下小写p把寄存器内容复制到当前位置之后，大写P把寄存器内容复制到当前位置之前。 e) 使用 :regs 命令可以列出当前所有寄存器的内容 8、一些插入模式下的常用快捷键 Ctrl+h - 删除光标左边字符 Ctrl+w - 删除光标左边的单词 Ctrl+y - 复制上方的一个字符 Ctrl+e - 复制下方的一个字符 Ctrl+r 0 - 插入前一次用y命令寄存的内容 Ctrl+r * - 插入系统剪贴板的内容 Ctrl+r &lt;寄存器名称&gt; - 插入指定寄存器的内容 Ctrl+a - 插入前一次插入模式所键入的内容 Ctrl+o - 执行一个普通模式下的命令然后返回插入模式。例如 Ctrl+o A 相当于按 End键， Ctrl+o I相当于按Home键 9、退出插入模式 退出插入模式可以用 ESC 键，但键位太远。其实也可以用 Ctrl+[ 键退出插入模式 。 当然也可以用第1点自定义的Ctrl+;快捷键，但这不是标准vim按键，会养成不良习惯，不建议使用。 10、重复操作 普通模式下按. （小数点）可重复上一次的修改操作 &amp; - 重复上一次的:s替换命令 @@ - 重复上一次执行的宏 11、跳转 Ctrl+] 跳转到当前标识符的定义位置 （相当于在当前光标位置的单词上按住ctrl用鼠标点击） Ctrl+o 回退一步 (go back) Ctrl+i 前进一步 (go forward) &#96;. 跳转到之前修改位置 &#96;&#96; 在前一次跳转位置与当前位置间切换 行号G 或 :行号&lt;回车&gt; 跳转到某一行 gg 跳转到文件开头 G 跳转到文件末尾 H 跳转到屏幕顶端（如果设置了set so&#x3D;n，则跳转到第n行） L 跳转到屏幕底端（如果设置了set so&#x3D;n，则跳转到倒数第n行） M 跳转到屏幕中间 f 或 F 跳转到本行某个字符，小写f向右查找，大写F向左查找。用;或,在匹配间切换 t 或 T 跳转到本行某个字符之前，小写t向右查找，大写T向左查找。用;或,在匹配间切换 &#x2F;正则表达式 跳转到下一个匹配。用n或N在匹配间切换。 ?正则表达式 跳转到上一个匹配。用n或N在匹配间切换。 结合前面第5点，你也许注意到了，在指定范围时，使用跳转命令将指定一个从光标位置到跳转目标的区域。 12、书签 在普通模式下按 m&lt;小写字母&gt; 即可定义书签，按 &#96;&lt;字母&gt; 则可跳转到某个书签的精确位置，按 ‘&lt;字母&gt;可跳转到某个书签所在行的行首（用来录制宏时比较有用）。 最常用的自然是mm, mn, mj, mk, ml这几个顺手的键位。 真正的vim中的全局书签 m&lt;大写字母&gt; 在目前IdeaVim版本中不生效。需要定义全局书签可以使用Idea原本的 F11 + 数字 方式。 13 、文本替换 使用 :s&#x2F;正则表达式&#x2F;替换文本&#x2F; 可在本行内替换首次出现的匹配 使用 :s&#x2F;正则表达式&#x2F;替换文本&#x2F;g 在本行内替换所有出现的匹配 使用 :%s&#x2F;正则表达式&#x2F;替换文本&#x2F;g 在当前文件内替换所有出现的匹配 在可视模式下选中文本后，使用:’&lt;,’&gt;s&#x2F;正则表达式&#x2F;替换文本&#x2F;g 命令可在选中区域中替换文本。 其中’&lt;,’&gt;部分在可视模式下，按:冒号后自动加入，直接输入s命令即可。但有效区域只能以行为单位。 真正Vim中的 %V 标志在IdeaVim中不生效。 14、代码折叠 zo - 打开折叠 zc - 关闭折叠 15 、宏定义 在IdeaVim中定义宏比Idea自带的宏功能要轻量许多。 按在普通模式下 q&lt;寄存器名称&gt; 即可开始把后续按键序列录制到指定寄存器中（寄存器参考前面第7条）。录制完毕进入普通模式再按q键即可停止录制。 之后用 @&lt;寄存器名称&gt; 即可重放。需要注意的是宏和复制粘贴共用一套寄存器，因此在录制宏时就注意不要把当前宏正在使用的寄存器用来复制了。 寄存器内容是自动保存的，重启Idea仍然生效。但IdeaVim没有导出宏独立保存的功能。因此最好把用来保存宏的寄存器和用来复制粘贴的寄存器分开，不要同一个寄存器有时用来记录宏，有时用来复制粘贴。我的习惯是键盘左手区用来保存一些长期使用的宏（比如说我有一个宏专门用来把pom.xml中的版本号抽取到property区域，原来的位置则改用${property}引用）。 右手区的hjklnm键用来保存一些临时宏。yuiop五个寄存器保留用来复制粘贴。如果录制的宏不涉及删除大段代码，寄存器1至9也可以用来进行复制粘贴。 执行一次宏后，可以用@@命令重复上一次执行的宏。 在Idea中录制宏时，如果触发了代码自动完成，在自动完成列表启动的状态输入的字符不会被记录。因此最好在Setting -&gt; Code Completion -&gt; Autopopup code completion中把延迟设为500ms以上或干脆关掉。在录制宏的过程中避免触发代码自动完成功能。 录制一些长期有效的宏时，开始录制后，最好先用0，^，T, F, $等命令把光标对齐到行首行末或某个特定起始位置（比如说用 F” 跳转到字符串的左边引号），再用一个f或&#x2F;指令跳转到操作位置，这样的宏就不用必须把光标放在某个特定字符才能使用了。 16、一些常用组合技 全选：ggvG 调换两个字符位置：xp 复制一行：yyp 调换两行位置：ddp 插入模式下到行尾继续输入（相当于End键）：Ctrl+o A 或 Ctrl+[ A 插入模式下到行首继续输入（相当于Home键）：Ctrl+o I 或 Ctrl+[ I 到类定义位置（适用于正确缩进的public，protected类） ：?^p回车 17、一些在目前版本已知没有实现的一些常用Vim功能 如果对Vim不熟悉可以跳过这节。 a）let命令 （没有let命令就无法导出&#x2F;导入寄存器内容，也就是无法导入宏） b）:g命令 （在文本处理中很有用的一个命令，在编程中倒是不那么常用） c）!命令 （执行shell命令） d）大部分正则表达式标记 （例如 %V， \\v 等等） e) 某些多键命令双击最后一个字符表示作用于当前行。例如在Vim中gUU可以把当前行转换为大写，在IdeaVim中无效，实现同样功能可以先用V命令选中当前行，再用gU转换为大写。 f）关于窗口操作的大部分命令 （Ctrl+w系列命令, :split等） g）所有Vim脚本插件 （不过大部分可以用Idea自身的功能和插件来补偿） 嗯，差点忘了，在普通模式下按u撤销上一个修改（相当于其他IDE的Ctrl+z），按Ctrl+r重做被撤销的修改。"},{"title":"Nginx常用配置","date":"2020-02-17T05:43:52.000Z","updated":"2021-12-10T04:23:02.809Z","comments":true,"path":"draft/nginx常用配置.html","permalink":"https://blog.wuhui2356.top/draft/nginx%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE.html","excerpt":"","text":"# Nginx代理配置"},{"title":"标签","date":"2019-08-13T06:43:11.000Z","updated":"2021-12-10T04:23:02.812Z","comments":true,"path":"tags/index.html","permalink":"https://blog.wuhui2356.top/tags/index.html","excerpt":"","text":""},{"title":"GRUB与GRUB2的区别","date":"2019-08-14T07:48:43.000Z","updated":"2021-12-10T04:23:02.808Z","comments":true,"path":"draft/Linux/grub与grub2的区别.html","permalink":"https://blog.wuhui2356.top/draft/Linux/grub%E4%B8%8Egrub2%E7%9A%84%E5%8C%BA%E5%88%AB.html","excerpt":"什么是GRUB 简单来说GRUB就是电脑开机过后运行的第一个程序，它负责加载操作系统内核并且将当前系统的控制权移交给操作系统内核。","text":"什么是GRUB 简单来说GRUB就是电脑开机过后运行的第一个程序，它负责加载操作系统内核并且将当前系统的控制权移交给操作系统内核。 详细信息参见GRUB的文件。 关于版本 GRUB2是将GRUB完全重构后的版本，所以又将之前版本的GRUB称为GRUB Legacy GRUB Legacy的最后一个版本为: 0.97，即0.97之后的版本均为Grub2,目前GRUB Legacy已经不再做开发了，只进行相关bug的修复，以保证一些旧的系统任然能够使用GRUB Legacy GRUB2的版本是从1.90开始，目前已经到了2.04,它与GRUB Legacy有许多相同的特性，具体的差异见下一小节。 GRUB2与GRUB Legacy的差异未完待续参考文档 项目地址 grub legacy文档 grub2文档 镜像地址"},{"title":"Linux下查看文件的创建时间","date":"2020-02-05T05:45:50.000Z","updated":"2021-12-10T04:23:02.808Z","comments":true,"path":"draft/Linux/linux下查看文件的创建时间.html","permalink":"https://blog.wuhui2356.top/draft/Linux/linux%E4%B8%8B%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6%E7%9A%84%E5%88%9B%E5%BB%BA%E6%97%B6%E9%97%B4.html","excerpt":"","text":""},{"title":"主引导记录MBR","date":"2019-08-14T07:38:26.000Z","updated":"2021-12-10T04:23:02.808Z","comments":true,"path":"draft/Linux/主引导记录MBR.html","permalink":"https://blog.wuhui2356.top/draft/Linux/%E4%B8%BB%E5%BC%95%E5%AF%BC%E8%AE%B0%E5%BD%95MBR.html","excerpt":"","text":"什么是MBR 主引导记录（Master Boot Record，缩写：MBR），又叫做主引导扇区，是计算机开机后访问硬盘时所必须要读取的首个扇区，它在硬盘上的三维地址为（柱面，磁头，扇区）＝（0，0，1）。参见维基百科 MBR说明结构 主引导扇区记录着硬盘本身的相关信息以及硬盘各个分区的大小及位置信息，是数据信息的重要入口,它位于硬盘的第一个扇区，即硬盘的前512个字节。这512字节又分为三个部分：启动代码、硬盘分区表、结束标志字。 启动代码： 硬盘的第 1-446 字节 (共446字节) 硬盘分区表: 硬盘的第 447-510 字节 (共64字节) 结束标志字: 硬盘的第 511-512 字节 (共2字节)，为 0x55 和 0xAA 启动代码 主引导记录最开头是第一阶段引导代码。其中的硬盘引导程序的主要作用是检查分区表是否正确并且在系统硬件完成自检以后将控制权交给硬盘上的引导程序（如GNU GRUB）。它不依赖任何操作系统，而且启动代码也是可以改变的，从而能够实现多系统引导。 硬盘分区表 硬盘分区表共64字节，又分为4项,每项16字节。故我们在对系统进行分区时，最多只能划分4个主分区或者3个主分区+1个扩展分区。 未完待续参考文档 https://wiki.osdev.org/MBR_(x86) https://en.wikipedia.org/wiki/Master_boot_record"},{"title":"树莓派常用配置","date":"2020-02-12T04:46:00.000Z","updated":"2021-12-10T04:23:02.809Z","comments":true,"path":"draft/Linux/树莓派常用配置.html","permalink":"https://blog.wuhui2356.top/draft/Linux/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE.html","excerpt":"","text":"基本信息 型号: 3B+ 操作系统: UBUNTU 18.04.4 LTS (Bionic Beaver) 网络配置（netplan） 配置文件路径: ​ /etc/netplan/50-cloud-init.yaml 配置文件内容: 12345678910# 配置静态IPnetwork: ethernets: enp0s3: dhcp4: false addresses: [192.168.0.201/24] gateway4: 192.168.0.1 nameservers: addresses: [192.168.0.1, 8.8.8.8] version: 2 应用配置: 1sudo netplan --debug apply"},{"title":"自定义CentOS7安装镜像","date":"2020-02-09T10:30:12.000Z","updated":"2021-12-10T04:23:02.809Z","comments":true,"path":"draft/Linux/自定义centos7安装镜像.html","permalink":"https://blog.wuhui2356.top/draft/Linux/%E8%87%AA%E5%AE%9A%E4%B9%89centos7%E5%AE%89%E8%A3%85%E9%95%9C%E5%83%8F.html","excerpt":"","text":"前言Anaconda是Red Hat和Fedora(红帽系,包括CentOS等)的安装程序,在Red Hat 7和Fedora 17之后对Anaconda进行了很大的优化,主要是加强用户的自定义能力.目前可以通过编写插件的方式来对安装程序和图形界面进行修改和扩展.本文主要阐述如何对以下内容的修改: 引导菜单 图形界面 扩展安装功能 注意: 本文只针对Red Hat 7 Fedora 17 CentOS 7及以上的操作系统 准备工作本文的实践过程以CentOS7.6的minimal安装镜像为基础,在此基础上进行修改,对安装功能进行自定义. 准备环境: CentOS7.6 虚拟机一台,默认已经安装完毕,下文的所有操作未特别说明,均在改虚拟机中进行. 下载镜像 镜像下载地址: http://vault.centos.org/7.6.1810/isos/x86_64&#x2F;CentOS-7-x86_64-Minimal-1810.iso,可以通过一下命令进行下载: 1wget http://vault.centos.org/7.6.1810/isos/x86_64/CentOS-7-x86_64-Minimal-1810.iso"},{"title":"C++动态加载lib的插件机制实现","date":"2020-01-03T13:44:25.000Z","updated":"2021-12-12T05:33:45.878Z","comments":true,"path":"draft/编程基础/C++动态加载DLL的插件机制实现.html","permalink":"https://blog.wuhui2356.top/draft/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/C++%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BDDLL%E7%9A%84%E6%8F%92%E4%BB%B6%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0.html","excerpt":"","text":"什么是插件插件，想必大家应该是陌生了吧，什么Vim、VS code、JetBrains全家桶啊都支持插件，但是这背后是如何实现的呢？今天我们就来好好掰扯掰扯。首先我们可以先来看看对插件比较官方的定义，还麻烦大家挪挪步百度百科关于插件的定义，但是这些都不重要，重要的是我们要如何来实现插件机制，如何实现在对已有程序不做任何修改的情况下，对程序功能的扩展。。。 需求大家先把菜刀准备好啊，需求要来了，贴个代码先： 12345int main(int argc, char *argv[])&#123; printf(&quot;Hello world.\\n&quot;); return 0;&#125; 没错，这就是一个简单的Hello world，但是呢, 产品汪A: 我这个项目要先打印一行123456再显示Hello world 产品汪B: 我这个项目要先先打印Hello world再打印123456 产品汪C: 我这个不显示Hello world，只打印123456 产品汪……. 这个栗子比较简单，一般我们遇到的需求比这个复杂多了，动不动就是某某功能里面，我要加一个什么什么逻辑，所以针对不同的需求，就要编译N个版本的exe进行交付，然后又要挨着全部测试N遍吗？不，插件机制，就能很好的帮我们解决这个问题。 引入插件后的程序结构 整个插件框架大概是这个样子的，最主要的编码工作是在PluginManager这个类里面，其他两个都是约定的接口，但是针对我们上面的需求，就是下面这个样子的： 其中IPrintEvent是定义的一个打印事件，而PrintPlugin则是具体的打印实现过程，即直接将PrintPlugin的打印实现直接变成so，然后由程序启动后进行动态加载即可。 废话就不多说了，是骡子是马，咱拉出来溜溜，首先贴个图，便于直观的理解。"},{"title":"golang从入门到放弃","date":"2020-02-03T14:36:07.000Z","updated":"2021-12-10T04:23:02.810Z","comments":true,"path":"draft/编程基础/golang从入门到放弃.html","permalink":"https://blog.wuhui2356.top/draft/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/golang%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83.html","excerpt":"","text":"前言Go（又称 Golang）是 Google 的 Robert Griesemer，Rob Pike 及 Ken Thompson 开发的一种静态强类型、编译型语言。Go 语言语法与 C相近，但功能上有：内存安全，GC(垃圾回收），结构形态及 CSP-style 并发计算。 包管理 Go Modgo modules 是 golang 1.11 添加的新特性(默认关闭)，在1.11之前的版本中，针对于第三方库的引用，直接讲对应的库文件放在GOPATH环境变量下即可，故通常会设置一个系统全局的GOPATH以及一个或者多个工程的GOPATH。但是在引入了go modules以后，就直接通过go.mod文件(该文件不能存在与GOPATH环境变量中)来进行第三方库的管理，同时需要设置环境变量GO111MODULE=on来开启go modules， 通过go get命令下载的所有库都会自动托管到go.mod文件中。 注意： goland中会遇到无法解析import进来的包，但是程序又能正常运行的情况，该种现象的出现就是两种包管理方式混乱了，直接采用go.mod文件这种方式对第三方包进行管理即可。如果包下载慢或者部分包无法下载的情况，参考另一篇文章设置代理即可。"}],"posts":[{"title":"npm常用命令","slug":"npm常用命令","date":"2022-02-07T04:20:11.000Z","updated":"2022-12-04T13:54:40.141Z","comments":true,"path":"2022/02/07/npm常用命令/","link":"","permalink":"https://blog.wuhui2356.top/2022/02/07/npm%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"","text":"说明NPM是随同NodeJS一起安装的包管理工具，能解决NodeJS代码部署上的很多问题，本文主要对NPM的基本使用、依赖包的升级方法等进行简要的记录说明。 常用命令 依赖包安装： npm install xxx 全局安装依赖包: npm install -g xxxx 查看缓存路径: npm config get cache 修改缓存路径: npm config set cache /path/a/b 查看依赖包是否已经过期: npm outdated 指定环境变量启动: npx cross-env NODE_OPTIONS=&quot;--trace-warnings&quot; hexo s 依赖包升级 安装工具： npm install -g npm-check-updates 通过ncu工具再次检查是否有依赖包需要进行升级操作: ncu 12345678910111213141516# 这里的ncu为上文安装的npm-check-updates工具的简写$ ncuChecking F:\\blog\\package.json[====================] 24/24 100% bufferutil ^4.0.5 → ^4.0.6 chokidar ^3.5.2 → ^3.5.3 hexo ^5.4.0 → ^6.0.0 hexo-renderer-marked ^4.1.0 → ^5.0.0 hexo-server ^2.0.0 → ^3.0.0 hexo-theme-next ^8.8.2 → ^8.9.0 marked ^4.0.6 → ^4.0.12 utf-8-validate ^5.0.7 → ^5.0.8Run ncu -u to upgrade package.json 更新package.json文件中的依赖包: ncu -u 1234567891011121314$ ncu -uUpgrading F:\\blog\\package.json[====================] 24/24 100% bufferutil ^4.0.5 → ^4.0.6 chokidar ^3.5.2 → ^3.5.3 hexo ^5.4.0 → ^6.0.0 hexo-renderer-marked ^4.1.0 → ^5.0.0 hexo-server ^2.0.0 → ^3.0.0 hexo-theme-next ^8.8.2 → ^8.9.0 marked ^4.0.6 → ^4.0.12 utf-8-validate ^5.0.7 → ^5.0.8Run npm install to install new versions. 更新指定依赖包到package.json中：ncu -u 包名 123456789$ ncu -u react-dev-inspector react-dom react-helmet-asyncUpgrading D:\\code\\openbastion\\src\\web_ui\\package.json react-dev-inspector ^1.7.0 → ^1.8.1 react-dom ^17.0.0 → ^18.2.0 react-helmet-async ^1.2.0 → ^1.3.0Run npm install to install new versions. 更新依赖包: npm install 123456$ npm installadded 7 packages, removed 3 packages, and changed 66 packages in 2m3 packages are looking for funding run `npm fund` for details","categories":[{"name":"npm","slug":"npm","permalink":"https://blog.wuhui2356.top/categories/npm/"}],"tags":[{"name":"npm","slug":"npm","permalink":"https://blog.wuhui2356.top/tags/npm/"}]},{"title":"Linux下常用调试方法命令","slug":"linux下常用调试方法命令","date":"2022-01-07T12:22:00.000Z","updated":"2022-12-04T13:54:40.124Z","comments":true,"path":"2022/01/07/linux下常用调试方法命令/","link":"","permalink":"https://blog.wuhui2356.top/2022/01/07/linux%E4%B8%8B%E5%B8%B8%E7%94%A8%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95%E5%91%BD%E4%BB%A4/","excerpt":"","text":"GDB调试 编译说明 需要通过GDB进行调试的程序，在进行编译时需要指定 -g 选项 启动参数 –directory: 指定调试时加载的源代码文件路径 例如: gdb --directory /opt/nginx/src --args /opt/nginx/sbin/nginx -g &quot;daemon off;&quot; –args: 后面直接跟 命令+参数，当再gdb中启动调试时，会以指定的参数启动程序 例如: gdb --args /opt/nginx/sbin/nginx -g &quot;daemon off;&quot; -x: 从指定文件中加载断点信息 常用调试命令 info info breakpoints —— 查看断点信息 info args —— 查看当前函数的参数 info locals —— 查看当前函数中的局部变量 info function 函数名 —— 进行函数查找，函数名支持通配符 info watch —— 查看所有的观察点 run(r)： 重新开始运行程序 break(s)： 断点 info breakpoints —— 查看所有断点信息 b 文件名:行号 —— 下断点到文件的指定行 文件名可以省略，表示对针对当前文件下断点 例如： b 100 b nginx.c:100 b 函数名 —— 对指定函数下断点 例如: b main delete breakpoints 数字 —— 删除第几个断点 save breakpoints aaa.txt —— 保存断点到指定文件，只能通过命令行参数从文件加载断点 continue(c) —— 继续运行，直到程序结束或者命中下一个断点 step(s) —— 单步调试（逐条语句执行，会进入函数内部） next(n) ——单步调试（逐过程执行，不会进入函数内部） backtrace(bt) —— 查看函数当前的栈帧和调用层级关系 frame(f) —— 栈帧操作 frame + 参数, 不指定参数则输出当前栈帧信息 例如：移动到栈帧2，再打印对应的变量信息 print(p) —— 打印值或地址信息 watch(w) —— 设置观察点，被观察的变量发生修改时，打印显示 多线程调试 thread: thread apply all cmd: 所有线程中执行指定的GDB命令 例如: thread apply all bt: 所有线程执行bt打印当前的调用栈 thread apply 线程ID cmd: 执行线程执行指定的GDB命令 常用设置 set print elements 0: 打印字符串指针的所有内容，不进行截断 set scheduler-locking on: 只运行当前线程 set follow-fork-mode [parent|child]: 设置调试 [父进程|子进程] show follow-fork-mode: 查看当前调试的父进程还是子进程 set detach-on-fork [on|off]: 设置调试当前进程时 [ 继续运行|挂起 ] 其他进程 show detach-on-fork [on|off]: 查看调试当前进程时继续运行还是挂起其他进程 set logging on 文件名: 将调试信息输出到指定文件 set pagination of: 关闭分页暂停的提示信息 strace 说明 跟踪程序或进程的系统调用 当我们怀疑某个进程卡死或者跑飞的时候 查看进程打开了哪些文件 查看进程当前卡在哪个系统调用 …………. 使用方法： strace -p 进程号 —— 查看正在运行的进程的系统调用 strace 进程路径 —— 通过strace命令启动进程，查看进程的系统调用信息","categories":[{"name":"Linux","slug":"linux","permalink":"https://blog.wuhui2356.top/categories/linux/"}],"tags":[{"name":"Linux","slug":"linux","permalink":"https://blog.wuhui2356.top/tags/linux/"},{"name":"调试","slug":"调试","permalink":"https://blog.wuhui2356.top/tags/%E8%B0%83%E8%AF%95/"},{"name":"gdb","slug":"gdb","permalink":"https://blog.wuhui2356.top/tags/gdb/"},{"name":"strace","slug":"strace","permalink":"https://blog.wuhui2356.top/tags/strace/"}]},{"title":"Linux 下扩展磁盘分区","slug":"linux-扩展磁盘分区","date":"2021-12-14T06:00:35.000Z","updated":"2021-12-14T07:10:15.248Z","comments":true,"path":"2021/12/14/linux-扩展磁盘分区/","link":"","permalink":"https://blog.wuhui2356.top/2021/12/14/linux-%E6%89%A9%E5%B1%95%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA/","excerpt":"","text":"查看磁盘信息查看磁盘使用状态12345678910[root@localhost ~]# df -hFilesystem Size Used Avail Use% Mounted ondevtmpfs 1.9G 0 1.9G 0% /devtmpfs 1.9G 0 1.9G 0% /dev/shmtmpfs 1.9G 12M 1.9G 1% /runtmpfs 1.9G 0 1.9G 0% /sys/fs/cgroup/dev/mapper/centos-root 18G 18G 9.2M 100% //dev/sda1 497M 169M 329M 34% /boot/dev/sdb1 100G 1.8G 99G 2% /hometmpfs 378M 0 378M 0% /run/user/0 查看磁盘分区结构123456789[root@localhost ~]# lsblkNAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINTsda 8:0 0 20G 0 disk├─sda1 8:1 0 500M 0 part /boot└─sda2 8:2 0 19.5G 0 part ├─centos-root 253:0 0 17.5G 0 lvm / └─centos-swap 253:1 0 2G 0 lvm [SWAP]sdb 8:16 0 100G 0 disk└─sdb1 8:17 0 100G 0 part /home 由上面的信息可知，我们当前系统的根分区空间满了，需要进行扩容操作。 添加磁盘及分区添加磁盘12345678910[root@localhost ~]# lsblkNAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINTsda 8:0 0 20G 0 disk├─sda1 8:1 0 500M 0 part /boot└─sda2 8:2 0 19.5G 0 part ├─centos-root 253:0 0 17.5G 0 lvm / └─centos-swap 253:1 0 2G 0 lvm [SWAP]sdb 8:16 0 100G 0 disk└─sdb1 8:17 0 100G 0 part /homesdc 8:32 0 50G 0 disk 如上所示，我们添加了一块磁盘，sdc，未进行任何格式化或者分区操作 创建分区表 由于磁盘空间只有50G，故这里对分区表没有要求，使用msdos或者GPT分区都行。注意如果空间大小超过了2TB，则必须采用GPT分区表。这里我们采用GPT分区表。 12345678910111213# 创建GPT分区表[root@localhost ~]# parted /dev/sdc mklabel GPTInformation: You may need to update /etc/fstab.# 查看磁盘信息[root@localhost ~]# parted /dev/sdc printModel: VMware, VMware Virtual S (scsi)Disk /dev/sdc: 53.7GBSector size (logical/physical): 512B/512BPartition Table: gptDisk Flags:Number Start End Size File system Name Flags 创建分区1234567891011121314# 创建一个主分区，分区起始地址为1MiB[root@localhost ~]# parted /dev/sdc mkpart primary xfs 1MiB 100%FREEInformation: You may need to update /etc/fstab.# 查看磁盘信息[root@localhost ~]# parted /dev/sdc printModel: VMware, VMware Virtual S (scsi)Disk /dev/sdc: 53.7GBSector size (logical/physical): 512B/512BPartition Table: gptDisk Flags:Number Start End Size File system Name Flags 1 1049kB 53.7GB 53.7GB primary 由于我们的扩容策略是将该磁盘上所有的空间全部扩容到根分区，故这里我们只需要在该磁盘上创建一个分区，分区大小是整个磁盘的容量大小即可。这里采用了1MIB对齐。 扩容指定分区创建物理卷 分区扩容我们是通过逻辑卷来完成了，首先我们先在上面创建的分区上创建物理卷 1234567891011121314151617# 创建物理卷[root@localhost ~]# pvcreate /dev/sdc1 Physical volume &quot;/dev/sdc1&quot; successfully created.# 查看物理卷信息[root@localhost ~]# pvdisplay /dev/sdc1 &quot;/dev/sdc1&quot; is a new physical volume of &quot;&lt;50.00 GiB&quot; --- NEW Physical volume --- PV Name /dev/sdc1 VG Name PV Size &lt;50.00 GiB Allocatable NO PE Size 0 Total PE 0 Free PE 0 Allocated PE 0 PV UUID 0hRpcz-o6gQ-4MtD-MuGs-ltT3-RoVk-3E9Oc5 查找目标卷组1234567891011121314151617181920212223242526272829303132333435# 查看逻辑卷信息[root@localhost ~]# lvdisplay --- Logical volume --- LV Path /dev/centos/swap LV Name swap VG Name centos LV UUID 60jdcJ-NQfJ-MT4K-rcrp-Gmbp-OY2S-gfdapy LV Write Access read/write LV Creation host, time localhost, 2018-07-08 05:32:48 +0800 LV Status available # open 2 LV Size 2.00 GiB Current LE 512 Segments 1 Allocation inherit Read ahead sectors auto - currently set to 8192 Block device 253:1 --- Logical volume --- LV Path /dev/centos/root LV Name root VG Name centos LV UUID 0D5etc-7klz-Im4Y-GHAs-0O8W-mrCU-JZCXGY LV Write Access read/write LV Creation host, time localhost, 2018-07-08 05:32:49 +0800 LV Status available # open 1 LV Size &lt;17.47 GiB Current LE 4472 Segments 1 Allocation inherit Read ahead sectors auto - currently set to 8192 Block device 253:0 由于我们扩容的逻辑卷是 &#x2F;dev&#x2F;centos&#x2F;root, 故其对应的卷组为centos，所以我们需要将新创建的物理卷 添加到centos这个卷组中 卷组扩容12345678910111213141516171819202122232425262728293031323334353637383940# 将物理卷 /dev/sdc1 添加到卷组centos中[root@localhost ~]# vgextend centos /dev/sdc1 Volume group &quot;centos&quot; successfully extended# 查看卷组centos的信息[root@localhost ~]# vgdisplay centos --- Volume group --- VG Name centos System ID Format lvm2 Metadata Areas 2 Metadata Sequence No 5 VG Access read/write VG Status resizable MAX LV 0 Cur LV 2 Open LV 2 Max PV 0 Cur PV 2 Act PV 2 VG Size 69.50 GiB PE Size 4.00 MiB Total PE 17793 Alloc PE / Size 4984 / &lt;19.47 GiB Free PE / Size 12809 / &lt;50.04 GiB VG UUID j21OCZ-h3yM-KMAD-fUdc-2KxW-wM1p-qhxcoa# 查看物理卷信息，此时物理卷信息中的卷组已经是centos了[root@localhost ~]# pvdisplay /dev/sdc1 --- Physical volume --- PV Name /dev/sdc1 VG Name centos PV Size &lt;50.00 GiB / not usable 2.00 MiB Allocatable yes PE Size 4.00 MiB Total PE 12799 Free PE 12799 Allocated PE 0 PV UUID 0hRpcz-o6gQ-4MtD-MuGs-ltT3-RoVk-3E9Oc5 逻辑卷扩容1234567891011121314151617181920212223# 逻辑卷扩容 50G[root@localhost ~]# lvextend -L &quot;+50G&quot; /dev/centos/root Size of logical volume centos/root changed from &lt;17.47 GiB (4472 extents) to &lt;67.47 GiB (17272 extents). Logical volume centos/root successfully resized.# 查看逻辑卷信息[root@localhost ~]# lvdisplay /dev/centos/root --- Logical volume --- LV Path /dev/centos/root LV Name root VG Name centos LV UUID 0D5etc-7klz-Im4Y-GHAs-0O8W-mrCU-JZCXGY LV Write Access read/write LV Creation host, time localhost, 2018-07-08 05:32:49 +0800 LV Status available # open 1 LV Size &lt;67.47 GiB Current LE 17272 Segments 2 Allocation inherit Read ahead sectors auto - currently set to 8192 Block device 253:0 文件系统扩容123456789101112131415161718192021222324# 对根分区的文件系统进行扩容[root@localhost ~]# xfs_growfs /meta-data=/dev/mapper/centos-root isize=256 agcount=4, agsize=1144832 blks = sectsz=512 attr=2, projid32bit=1 = crc=0 finobt=0 spinodes=0data = bsize=4096 blocks=4579328, imaxpct=25 = sunit=0 swidth=0 blksnaming =version 2 bsize=4096 ascii-ci=0 ftype=0log =internal bsize=4096 blocks=2560, version=2 = sectsz=512 sunit=0 blks, lazy-count=1realtime =none extsz=4096 blocks=0, rtextents=0data blocks changed from 4579328 to 17686528# 查看分区大小[root@localhost ~]# df -hFilesystem Size Used Avail Use% Mounted ondevtmpfs 1.9G 0 1.9G 0% /devtmpfs 1.9G 0 1.9G 0% /dev/shmtmpfs 1.9G 12M 1.9G 1% /runtmpfs 1.9G 0 1.9G 0% /sys/fs/cgroup/dev/mapper/centos-root 68G 18G 51G 26% //dev/sda1 497M 169M 329M 34% /boot/dev/sdb1 100G 1.8G 99G 2% /hometmpfs 378M 0 378M 0% /run/user/0","categories":[{"name":"Linux","slug":"linux","permalink":"https://blog.wuhui2356.top/categories/linux/"}],"tags":[{"name":"Linux","slug":"linux","permalink":"https://blog.wuhui2356.top/tags/linux/"},{"name":"分区","slug":"分区","permalink":"https://blog.wuhui2356.top/tags/%E5%88%86%E5%8C%BA/"},{"name":"parted","slug":"parted","permalink":"https://blog.wuhui2356.top/tags/parted/"},{"name":"逻辑卷","slug":"逻辑卷","permalink":"https://blog.wuhui2356.top/tags/%E9%80%BB%E8%BE%91%E5%8D%B7/"}]},{"title":"常用工具国内镜像源配置","slug":"常用工具国内镜像源配置","date":"2021-12-13T06:32:25.000Z","updated":"2021-12-14T07:10:15.249Z","comments":true,"path":"2021/12/13/常用工具国内镜像源配置/","link":"","permalink":"https://blog.wuhui2356.top/2021/12/13/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E5%9B%BD%E5%86%85%E9%95%9C%E5%83%8F%E6%BA%90%E9%85%8D%E7%BD%AE/","excerpt":"","text":"前言我们的日常开发过程中会使用到很多的第三方工具，但是由于大部分工具的源（扩展包、库）都在国外，在线下载非常慢，耗时久。但是一般情况下，国内的大厂或者一些高校等都会对常用的工具免费提供对应的镜像仓库，故在我们的开发过程中直接使用国内的镜像网站，即可加速下载，节约大量的时间。 npm 国内镜像源配置NPM（Node Package Manager），是NodeJs的模块依赖管理工具。一般情况下使用淘宝的源即可，可以直接执行以下命令进行配置： 12345// 临时配置npm --registry https://registry.npm.taobao.org install express// 持久化配置npm config set registry https://registry.npm.taobao.org 配置完成后可以执行以下命令查看当前使用的源： 123npm info expressnpm config get registry Golang 代理配置Go（又称 Golang）是 Google 的 Robert Griesemer，Rob Pike 及 Ken Thompson 开发的一种静态强类型、编译型语言。Go 语言语法与 C相近，但功能上有：内存安全，GC(垃圾回收），结构形态及 CSP-style 并发计算。需要下载除SDK中自带的库时，可以直接使用以下代理地址： 12https://goproxy.cnhttps://goproxy.io 直接添加以下环境变量即可： 12export GO111MODULE=onexport GOPROXY=https://goproxy.cn,direct 在GoLand中进行如下图所示的设置即可： 然后通过以下命令下载对应的包即可： 1go get &lt;package&gt; 参考链接： GoProxy中国","categories":[{"name":"其他","slug":"其他","permalink":"https://blog.wuhui2356.top/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"npm","slug":"npm","permalink":"https://blog.wuhui2356.top/tags/npm/"},{"name":"工具","slug":"工具","permalink":"https://blog.wuhui2356.top/tags/%E5%B7%A5%E5%85%B7/"},{"name":"node","slug":"node","permalink":"https://blog.wuhui2356.top/tags/node/"},{"name":"maven","slug":"maven","permalink":"https://blog.wuhui2356.top/tags/maven/"},{"name":"mvn","slug":"mvn","permalink":"https://blog.wuhui2356.top/tags/mvn/"},{"name":"golang","slug":"golang","permalink":"https://blog.wuhui2356.top/tags/golang/"}]},{"title":"逻辑卷LVM相关操作","slug":"逻辑卷LVM相关的操作","date":"2021-12-13T01:30:30.000Z","updated":"2022-02-07T04:21:04.308Z","comments":true,"path":"2021/12/13/逻辑卷LVM相关的操作/","link":"","permalink":"https://blog.wuhui2356.top/2021/12/13/%E9%80%BB%E8%BE%91%E5%8D%B7LVM%E7%9B%B8%E5%85%B3%E7%9A%84%E6%93%8D%E4%BD%9C/","excerpt":"","text":"什么是逻辑卷 逻辑卷（lv）是将几个磁盘分区或者块设备(pv，pv的id必须是8e的，pv可以位于不同的磁盘分区里，pv大小可以不一)组织起来形成一个大的扩展分区（vg,卷组，一个vg至少要包含一个pv。），该扩展分区不能直接用，需要将其划分成逻辑卷（lv）才能使用，lv可以格式化成不同的文件系统，挂载后直接使用。 lv的扩展和缩减是不会影响原有数据的，但逻辑卷缩减的风险大于逻辑卷扩展的风险。 逻辑卷可以支持快照功能。 相关术语 物理卷（PV, Physical Volume） 物理卷就是指磁盘,磁盘分区或从逻辑上和磁盘分区具有同样功能的设备(如RAID)，是LVM的基本存储逻辑块，但和基本的物理存储介质（如分区、磁盘等）比较，却包含有和LVM相关的管理参数。当前LVM允许你在每个物理卷上保存这个物理卷的0至2份元数据拷贝.默认为1,保存在设备的开始处.为2时,在设备结束处保存第二份备份. 卷组（VG, Volume Group） LVM卷组类似于非LVM系统中的物理硬盘，其由物理卷组成。能在卷组上创建一个或多个“LVM分区”（逻辑卷），LVM卷组由一个或多个物理卷组成。 逻辑卷（LV, Logical Volume） LVM的逻辑卷类似于非LVM系统中的硬盘分区，在逻辑卷之上能建立文件系统(比如&#x2F;home或&#x2F;usr等)。 线性逻辑卷 (Linear Volumes) 一个线性逻辑卷聚合多个物理卷成为一个逻辑卷.比如,如果你有两个60GB硬盘,你能生成120GB的逻辑卷. 条块化的逻辑卷(Striped Logical Volumes) 当你写数据到此逻辑卷中时,文件系统能将数据放置到多个物理卷中.对于大量连接读写操作,他能改善数据I&#x2F;O效率. 映像的逻辑卷(Mirrored Logical Volumes) 映像在不同的设备上保存一致的数据.数据同时被写入原设备及映像设备.他提供设备之间的容错。 快照卷(Snapshot Volumes) 快照卷提供在特定瞬间的一个设备虚拟映像，当快照开始时，他复制一份对当前数据区域的改动，由于他优先执行这些改动，所以他能重构当前设备的状态。 参考: https://www.cnblogs.com/shxdyz/articles/7834980.html 查看逻辑卷信息查看LV lvscan 123[root@localhost ~]# lvscan ACTIVE &#x27;/dev/centos/swap&#x27; [2.00 GiB] inherit ACTIVE &#x27;/dev/centos/root&#x27; [&lt;67.47 GiB] inherit lvdisplay 12345678910111213141516171819202122232425262728293031323334[root@localhost ~]# lvdisplay --- Logical volume --- LV Path /dev/centos/swap LV Name swap VG Name centos LV UUID 60jdcJ-NQfJ-MT4K-rcrp-Gmbp-OY2S-gfdapy LV Write Access read/write LV Creation host, time localhost, 2018-07-08 05:32:48 +0800 LV Status available # open 2 LV Size 2.00 GiB Current LE 512 Segments 1 Allocation inherit Read ahead sectors auto - currently set to 8192 Block device 253:1 --- Logical volume --- LV Path /dev/centos/root LV Name root VG Name centos LV UUID 0D5etc-7klz-Im4Y-GHAs-0O8W-mrCU-JZCXGY LV Write Access read/write LV Creation host, time localhost, 2018-07-08 05:32:49 +0800 LV Status available # open 1 LV Size &lt;67.47 GiB Current LE 17272 Segments 2 Allocation inherit Read ahead sectors auto - currently set to 8192 Block device 253:0 查看VG vgscan 123[root@localhost ~]# vgscan Reading volume groups from cache. Found volume group &quot;centos&quot; using metadata type lvm2 vgdisplay 123456789101112131415161718192021[root@localhost ~]# vgdisplay --- Volume group --- VG Name centos System ID Format lvm2 Metadata Areas 2 Metadata Sequence No 6 VG Access read/write VG Status resizable MAX LV 0 Cur LV 2 Open LV 2 Max PV 0 Cur PV 2 Act PV 2 VG Size 69.50 GiB PE Size 4.00 MiB Total PE 17793 Alloc PE / Size 17784 / &lt;69.47 GiB Free PE / Size 9 / 36.00 MiB VG UUID j21OCZ-h3yM-KMAD-fUdc-2KxW-wM1p-qhxcoa 查看PV pvscan 1234[root@localhost ~]# pvscan PV /dev/sda2 VG centos lvm2 [&lt;19.51 GiB / 0 free] PV /dev/sdc1 VG centos lvm2 [&lt;50.00 GiB / 36.00 MiB free] Total: 2 [69.50 GiB] / in use: 2 [69.50 GiB] / in no VG: 0 [0 ] pvdisplay 12345678910111213141516171819202122[root@localhost ~]# pvdisplay --- Physical volume --- PV Name /dev/sda2 VG Name centos PV Size 19.51 GiB / not usable 3.00 MiB Allocatable yes (but full) PE Size 4.00 MiB Total PE 4994 Free PE 0 Allocated PE 4994 PV UUID YK8Rel-8zLh-Ri9E-fMtJ-G5TQ-rOfD-Mkg4q5 --- Physical volume --- PV Name /dev/sdc1 VG Name centos PV Size &lt;50.00 GiB / not usable 2.00 MiB Allocatable yes PE Size 4.00 MiB Total PE 12799 Free PE 9 Allocated PE 12790 PV UUID 0hRpcz-o6gQ-4MtD-MuGs-ltT3-RoVk-3E9Oc5 创建逻辑卷说明 再创建逻辑卷时，应当先创建物理卷(pv)，再创建卷组(vg)，最后再创建逻辑卷(lv) 创建PV pvcreate12345678pvcreate &lt;device&gt;// device: 要创建物理卷的设备路径示例:[root@localhost ~]# pvcreate /dev/sda1 Physical volume &quot;/dev/sda1&quot; successfully created 创建VG vgcreate123456789vgcreate &lt;vg_name&gt; &lt;pv list&gt;// vg_name: 卷组名// device list: 要添加到卷组的物理卷pv列表示例:[root@localhost ~]# vgcreate vg_test /dev/sda1 /dev/sdc1 Volume group &quot;vg_test&quot; successfully created 修改卷组属性 vgchange 激活卷组: vgchange -ay vg_test 创建LV lvcreate1234567891011121314lvcreate -n &lt;lv_name&gt; -L &lt;size&gt; &lt;vg_name&gt; -ylvcreate -n &lt;lv_name&gt; -l &lt;size&gt; &lt;vg_name&gt; -y// -L: 指定大小(--size LogicalVolumeSize[bBsSkKmMgGtTpPeE])// -l: 可以指定百分比(--extents LogicalExtentsNumber[%&#123;VG|FREE|ORIGIN&#125;]),如 100%FREE// lv_name: 逻辑卷名// size： 创建的卷大小// vg_name: 卷组名示例: lvcreate -n &quot;lv_swap&quot; -L &quot;2GiB&quot; &quot;vg_test&quot; -y lvcreate -n &quot;lv_data&quot; -l &quot;100%FREE&quot; &quot;vg_test&quot; -y 删除逻辑卷说明 在删除逻辑卷之前，应当先卸载掉已经被挂载的分区，然后再进行逻辑卷的删除。 在卸载分区时，如果遇到当前分区正在被使用，无法进行卸载的情况，可以借助lsof命令找到正在占用挂载点的进程，然后将其kill掉，再进行卸载在操作。 逻辑卷的删除顺序与创建顺序相反，首先删除逻辑卷(lv)，然后删除卷组(vg)，最后删除物理卷(pv) 删除LV lvremove12[root@localhost ~]# lvremove /dev/VG_TEST/LV_SWAP -f -y Logical volume &quot;LV_SWAP&quot; successfully removed 删除VG vgremove12[root@localhost ~]# vgremove VG_TEST -f -y Volume group &quot;VG_TEST&quot; successfully removed 删除PV pvremove12[root@localhost ~]# pvremove /dev/sdb1 -f -y Labels on physical volume &quot;/dev/sdb1&quot; successfully wiped. 磁盘分区创建磁盘分区 创建分区表,采用 msdos(MBR)或者GPT GPT分区表: parted -s /dev/sdd mklabel gpt MBR分区表: parted -s /dev/sdd mklabel msdos 创建主分区: 123456789101112parted -s &lt;device&gt; mkpart &lt;part-type&gt; [fs-type] start end// deice: 指定磁盘设备// part-type: 只能为 primary(主分区)、logical(逻辑分区)、extended(扩展分区)// fs-type: 非必填参数,可以为: &quot;btrfs&quot;, &quot;ext2&quot;, &quot;ext3&quot;, &quot;ext4&quot;, &quot;fat16&quot;, &quot;fat32&quot;, &quot;hfs&quot;, &quot;hfs+&quot;, &quot;linux-swap&quot;, &quot;ntfs&quot;, &quot;reiserfs&quot;, or &quot;xfs&quot;// start: 指定分区开始位置，默认为磁盘起始位置// end: 指定分区结束位置,默认为磁盘结束位置示例: parted -s /dev/sdd mkpart primary 4MiB 100% // 在 /dev/sdd 上创建一个主分区，从4MiB的位置开始，到磁盘末尾结束 // 即整个分区大小为 磁盘大小-4MiB 修改分区表状态12345678910parted -s &lt;device&gt; toggle &lt;partition_number&gt; &lt;status&gt;// device: 指定磁盘设备// partition_number: 该磁盘设备上的第几个分区// status: 转换后的状态(raid|lvm)示例: parted -s /dev/sdd toggle 1 &quot;lvm&quot; // 将 /dev/sdd 上的第一个分区标记为 lvm 删除磁盘分区 可以通过parted删除指定的某个分区: parted -s /dev/sdc rm 1123456789parted -s &lt;device&gt; rm &lt;partition_number&gt;// device: 指定磁盘设备// partition_number: 该磁盘设备上的第几个分区示例: parted -s /dev/sdc rm 1 // 删除 /dev/sdc 上的第一个分区 一般情况下，如果要摧毁整个磁盘分区，那么只需要将磁盘首部的分区表摧毁掉就行了，所以，可以直接采用dd命令: dd if=/dev/zero of=/dev/sdd bs=16MiB count=1 磁盘格式化 制作交换分区: mkswap 123456789mkswap -f -L &lt;label&gt; &lt;device&gt;// device: 指定磁盘设备// label: 指定交换分区的标签label示例： mkswap -f -L label_swap /dev/vg_test/lv_swap 格式化: mkfs 12345678910111213mkfs.&lt;fs&gt; -L &lt;label&gt; &lt;device&gt;// fs: 文件系统格式// device: 指定磁盘设备// label: 指定交换分区的标签label示例: mkfs.xfs -L label_data /dev/vg_test/lv_data mkfs.ext4 -L label_data /dev/vg_test/lv_data mkfs -t xfs -L label_data /dev/vg_test/lv_data mkfs -t ext4 -L label_data /dev/vg_test/lv_data 数据无价，操作需谨慎参考文献 https://blog.csdn.net/solaraceboy/article/details/78539233 https://www.cnblogs.com/shxdyz/articles/7834980.html","categories":[{"name":"Linux","slug":"linux","permalink":"https://blog.wuhui2356.top/categories/linux/"}],"tags":[{"name":"Linux","slug":"linux","permalink":"https://blog.wuhui2356.top/tags/linux/"},{"name":"分区","slug":"分区","permalink":"https://blog.wuhui2356.top/tags/%E5%88%86%E5%8C%BA/"},{"name":"逻辑卷","slug":"逻辑卷","permalink":"https://blog.wuhui2356.top/tags/%E9%80%BB%E8%BE%91%E5%8D%B7/"},{"name":"LVM","slug":"lvm","permalink":"https://blog.wuhui2356.top/tags/lvm/"}]},{"title":"syslog协议","slug":"syslog协议","date":"2021-12-10T09:38:00.000Z","updated":"2021-12-14T07:10:58.238Z","comments":true,"path":"2021/12/10/syslog协议/","link":"","permalink":"https://blog.wuhui2356.top/2021/12/10/syslog%E5%8D%8F%E8%AE%AE/","excerpt":"","text":"简介 syslog协议属于一种主从式协议，通常被用于信息系统管理及信息安全审核。虽然它有不少缺陷，但仍获得相当多的设备及各种平台的接收端支持。因此syslog能被用来将来自许多不同类型系统的日志记录集成到集中的存储库中。 协议内容 syslog格式为一个长字符串，整个数据报分为三个部分：PRI、HEADER、MSG PRI: 只能为3、4、5个字符，并且以小于符号开始，以大于符号结束，中间为一个1到3位的数字 HEADER: 由TimeStamp与HostName组成。HEADER部分紧跟PRI，中间没有空格。TimeStamp与HostName之间间隔一个空格。HostName后面紧跟一个空格。 TimeStamp: 字段使用local time，格式为：Mmm dd hh:mm:ss Mmm: 是英语月份的单词缩写，例如：Jan, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Oct, Nov, Dec dd: 某个月的多少号，固定宽度2个字符，不足两个字符在数字前面用空格填充。 hh:mm:ss: 本地时间 hh: 24时制的小时，在00-23之间 mm和ss： 分和秒，在00-59之间 HostName: 该字段为主机的hostname。该字段后面紧跟一个空格 MSG: 该字段又两部分组成： TAG和CONTENT TAG: 该字段的值为产生日志的程序名，即推送日志到外部系统的程序名（不超过32个字符）。TAG后面紧跟一个用中括号包含着的pid,即[pid],并且再追加一个:,pid为该推送程序的进程号 CONTENT: 该字段为具体的日志内容 综上，整个数据报为：1&lt;xxx&gt;Mmm dd hh:mm:ss hostname tag[pid]: xxxxxxxxx rsyslog服务器配置安装syslog服务1sudo yum install rsyslog -y 修改配置文件123456789$ModLoad imudp$UDPServerRun 514$ModLoad imtcp$InputTCPServerRun 514$template RemoteLogs,&quot;/var/log/%HOSTNAME%/%PROGRAMNAME%.log&quot; **.* ?RemoteLogs&amp; ~ 启动rsyslog服务生效1systemctl restart rsyslog 参考文献","categories":[{"name":"Linux","slug":"linux","permalink":"https://blog.wuhui2356.top/categories/linux/"}],"tags":[{"name":"syslog","slug":"syslog","permalink":"https://blog.wuhui2356.top/tags/syslog/"},{"name":"linux","slug":"linux","permalink":"https://blog.wuhui2356.top/tags/linux/"}]},{"title":"Docker常用命令","slug":"Docker常用命令","date":"2021-12-03T13:44:25.000Z","updated":"2022-02-13T14:04:00.622Z","comments":true,"path":"2021/12/03/Docker常用命令/","link":"","permalink":"https://blog.wuhui2356.top/2021/12/03/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"","text":"安装CentOS 卸载旧版docker 12345678sudo yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine 添加仓库、源 12345678# 先安装yum-utils工具sudo yum install yum-utils -y# 添加阿里云源sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo# 官方源sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo 下载安装 1sudo yum install docker-ce docker-ce-cli containerd.io -y 启动docker服务 1234567891011121314# 启动sudo systemctl start docker# 停止sudo systemctl stop docker# 重启sudo systemctl restart docker# 开机自启sudo systemctl enable docker# 取消开机自启sudo systemctl disable docker 常用命令配置项 修改源 12345678910111213# 配置文件: /etc/docker/daemon.json &#123; &quot;registry-mirrors&quot;: [&quot;https://z34u8nau.mirror.aliyuncs.com&quot;]&#125;# 重载配置文件systemctl daemon-reload# 重启服务systemctl restart docker# 可能会需要登录操作sudo docker login --username=用户名 registry.cn-hangzhou.aliyuncs.com 镜像操作 docker images 查看当前已下载的镜像: docker images 查看当前没有tag的镜像: docker images -f “dangling&#x3D;true” docker search 查找镜像: docker search xxxxx docker pull 拉取镜像： docker pull xxxxx docker save 导出镜像: docker save 镜像tag -o xxx.tar docker rmi 删除镜像: docker rmi 镜像名称 删除没有tag的镜像: docker rmi $(docker images -f “dangling&#x3D;true” -q) -f docker imspect 查看镜像的信息: docker inspect 进行名称 容器操作 docker run 启动容器: docker run xxxx 交互式启动容器: docker run -it xxxx &#x2F;bin&#x2F;bash 后台启动容器: docker run -d xxxx 启动命令 docker exec 在指定容器中执行程序: docker exec -it 容器ID CMD 例如: docker exec -it aa7c1b0a86ca /bin/bash docker ps 查看当前运行的容器: docker ps docker logs 查看容器的输出信息: docker logs 容器ID docker stop 停止容器: docker stop 容器ID docker attach 重新获取容器的终端： docker attach 容器ID docker export 导出容器：docker export 容器ID &gt; xxxxx.img docker import 导入容器: cat xxxx.img | docker import - test&#x2F;ubuntu:v1 docker rm 删除容器: docker rm -f 容器ID 推送镜像 修改配置： 1234567#配置文件 /etc/docker/daemon.json &#123; &quot;registry-mirrors&quot;: [&quot;https://z34u8nau.mirror.aliyuncs.com&quot;], &quot;insecure-registries&quot;:[&quot;192.168.1.220:51005&quot;]&#125;#添加 insecure-registries 配置（本地的服务器地址和端口） 推送镜像到本地仓库 将镜像tag重命名: docker tag registry:2.7.1 192.168.1.220:51005&#x2F;offline&#x2F;registry:2.7.1 推送镜像: docker push 192.168.1.220:51005&#x2F;offline&#x2F;registry:2.7.1 dockerfile 命令 说明 FROM 指定使用的基础镜像，基于哪个镜像来指针当前的镜像 RUN 在构建容器时，在容器内执行指定的Shell命令(docker build 时执行) COPY 拷贝文件到容器中的指定目录 CMD 启动容器时，执行指定的命令(docker run 时执行，该命令与容器共存亡)，该命令结束，则容器运行结束。可被docker run命令行中指定的参数所覆盖。如果一个Dockerfile中存在多个CMD命令，则只有最后一条生效。 USER 指定镜像运行时，默认的用户身份 EXPOSE 声明容器的暴露端口 dockerfile文件示例 123456###################################################FROM centos:centos7.9.2009RUN yum install epel-release -yRUN yum install git cppcheck gcc gcc-c++ make cmake3 -y &amp;&amp; ln -sv cmake3 /usr/bin/cmakeCOPY a.txt /root/a.txtUSER root 构建镜像 123docker build -t nginx:v3 .# docker build -t 标签名称 Dockerfile所在的目录","categories":[{"name":"Linux","slug":"linux","permalink":"https://blog.wuhui2356.top/categories/linux/"}],"tags":[{"name":"Docker","slug":"docker","permalink":"https://blog.wuhui2356.top/tags/docker/"},{"name":"容器","slug":"容器","permalink":"https://blog.wuhui2356.top/tags/%E5%AE%B9%E5%99%A8/"},{"name":"Linux","slug":"linux","permalink":"https://blog.wuhui2356.top/tags/linux/"}]},{"title":"nginx内存池管理","slug":"nginx内存池管理","date":"2021-01-03T23:44:00.000Z","updated":"2022-02-07T07:10:00.001Z","comments":true,"path":"2021/01/03/nginx内存池管理/","link":"","permalink":"https://blog.wuhui2356.top/2021/01/03/nginx%E5%86%85%E5%AD%98%E6%B1%A0%E7%AE%A1%E7%90%86/","excerpt":"","text":"数据结构定义 ngx_pool_s——内存池管理结构 123456789struct ngx_pool_s &#123; ngx_pool_data_t d; // 用于小内存分配的data域 size_t max; // pool上单个节点的最大容量(不是可用容量) ngx_pool_t *current; // 指向当前pool用于内存分配的pool节点 ngx_chain_t *chain; ngx_pool_large_t *large; // 链表,保存开辟的大内存空间 ngx_pool_cleanup_t *cleanup; // 需要回收的内存链表 ngx_log_t *log;&#125;; ngx_pool_data_t——管理用于内存分配的数据域 123456typedef struct &#123; u_char *last; // 内存池下一次分配的起始地址 u_char *end; // 内存池的结束地址 ngx_pool_t *next; // 下一个内存池节点 ngx_uint_t failed; // 分配内存失败的次数&#125; ngx_pool_data_t; ngx_pool_large_s——大内存块 1234struct ngx_pool_large_s &#123; ngx_pool_large_t *next; void *alloc; // 保存开辟的大内存块&#125;; ngx_pool_cleanup_s——自定义内存回收的结构 12345678struct ngx_pool_cleanup_s &#123; ngx_pool_cleanup_pt handler; // 用于回收内存的处理函数 void *data; // 待回收的内存 ngx_pool_cleanup_t *next;&#125;;// 进行自定义内存回收处理的回调函数typedef void (*ngx_pool_cleanup_pt)(void *data); ngx_pool_cleanup_file_t——进行文件清理的结构 12345typedef struct &#123; ngx_fd_t fd; u_char *name; ngx_log_t *log;&#125; ngx_pool_cleanup_file_t; 图解 分配流程 nginx中进行内存分配的流程大致如下 具体实现接口函数内存池操作12345678// 创建单个节点大小为size的内存池ngx_pool_t *ngx_create_pool(size_t size, ngx_log_t *log);// 销毁释放内存池void ngx_destroy_pool(ngx_pool_t *pool);// 重置内存池为初始状态void ngx_reset_pool(ngx_pool_t *pool); 内存操作1234567891011121314// 通过内存池进行内存分配，并进行内存对齐void *ngx_palloc(ngx_pool_t *pool, size_t size);// 通过内存池进行内存分配，不进行内存对齐void *ngx_pnalloc(ngx_pool_t *pool, size_t size);// 通过内存池进行内存分配，进行内存对齐，并且将内存区域初始化为0void *ngx_pcalloc(ngx_pool_t *pool, size_t size);// 直接开辟size大小内存，并将该内存块保存在large链上void *ngx_pmemalign(ngx_pool_t *pool, size_t size, size_t alignment);// 内存释放，但是只会释放保存在large链上的大内存块，并且不会释放链表节点ngx_int_t ngx_pfree(ngx_pool_t *pool, void *p); 特殊操作1234567891011121314// 在cleanup 链上添加一个节点并返回ngx_pool_cleanup_t *ngx_pool_cleanup_add(ngx_pool_t *p, size_t size);// 清理cleanup链上指定的fdvoid ngx_pool_run_cleanup_file(ngx_pool_t *p, ngx_fd_t fd);// 文件清理的处理函数// 该函数作为cleanup链上的handlervoid ngx_pool_cleanup_file(void *data);// 通过内存池的cleanup链删除文件，以及清理文件描述符// 该函数作为cleanup链上的handlervoid ngx_pool_delete_file(void *data); 源码解析内存池操作ngx_create_pool12345678910111213141516171819202122232425262728293031ngx_pool_t *ngx_create_pool(size_t size, ngx_log_t *log)&#123; ngx_pool_t *p; // 开辟 size 大小的内存(通过malloc实现) p = ngx_memalign(NGX_POOL_ALIGNMENT, size, log); if (p == NULL) &#123; return NULL; &#125; // 内存区域的首部预留 sizeof(ngx_pool_t) 的大小 // 作为内存管理结构的内存空间 p-&gt;d.last = (u_char *) p + sizeof(ngx_pool_t); p-&gt;d.end = (u_char *) p + size; p-&gt;d.next = NULL; p-&gt;d.failed = 0; size = size - sizeof(ngx_pool_t); // p-&gt;max 最大只能为 pagesize -1 的大小 p-&gt;max = (size &lt; NGX_MAX_ALLOC_FROM_POOL) ? size : NGX_MAX_ALLOC_FROM_POOL; p-&gt;current = p; p-&gt;chain = NULL; p-&gt;large = NULL; p-&gt;cleanup = NULL; p-&gt;log = log; return p;&#125; ngx_destroy_pool12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455voidngx_destroy_pool(ngx_pool_t *pool)&#123; ngx_pool_t *p, *n; ngx_pool_large_t *l; ngx_pool_cleanup_t *c; // 处理cleanup链上的数据,通过handler进行处理释放 for (c = pool-&gt;cleanup; c; c = c-&gt;next) &#123; if (c-&gt;handler) &#123; ngx_log_debug1(NGX_LOG_DEBUG_ALLOC, pool-&gt;log, 0, &quot;run cleanup: %p&quot;, c); c-&gt;handler(c-&gt;data); &#125; &#125;#if (NGX_DEBUG) /* * we could allocate the pool-&gt;log from this pool * so we cannot use this log while free()ing the pool */ // 打印large链上的节点和地址 for (l = pool-&gt;large; l; l = l-&gt;next) &#123; ngx_log_debug1(NGX_LOG_DEBUG_ALLOC, pool-&gt;log, 0, &quot;free: %p&quot;, l-&gt;alloc); &#125; // 打印内存池节点的地址和内存大小 for (p = pool, n = pool-&gt;d.next; /* void */; p = n, n = n-&gt;d.next) &#123; ngx_log_debug2(NGX_LOG_DEBUG_ALLOC, pool-&gt;log, 0, &quot;free: %p, unused: %uz&quot;, p, p-&gt;d.end - p-&gt;d.last); if (n == NULL) &#123; break; &#125; &#125;#endif // 释放large链上的大内存 for (l = pool-&gt;large; l; l = l-&gt;next) &#123; if (l-&gt;alloc) &#123; ngx_free(l-&gt;alloc); &#125; &#125; // 释放pool链 for (p = pool, n = pool-&gt;d.next; /* void */; p = n, n = n-&gt;d.next) &#123; ngx_free(p); if (n == NULL) &#123; break; &#125; &#125;&#125; ngx_destroy_pool12345678910111213141516171819202122232425// 重置内存池为初始状态voidngx_reset_pool(ngx_pool_t *pool)&#123; ngx_pool_t *p; ngx_pool_large_t *l; // 释放large链上的大内存空间 for (l = pool-&gt;large; l; l = l-&gt;next) &#123; if (l-&gt;alloc) &#123; ngx_free(l-&gt;alloc); &#125; &#125; // 重置内存池链上所有节点的内存，设为未使用状态 for (p = pool; p; p = p-&gt;d.next) &#123; p-&gt;d.last = (u_char *) p + sizeof(ngx_pool_t); p-&gt;d.failed = 0; &#125; // current链指向第一个节点 pool-&gt;current = pool; pool-&gt;chain = NULL; pool-&gt;large = NULL;&#125; 内存操作ngx_palloc1234567891011121314// 通过内存池分配内存，进行内存对齐void *ngx_palloc(ngx_pool_t *pool, size_t size)&#123;#if !(NGX_DEBUG_PALLOC) // 如果请求的内存大小小于 pool-&gt;max, 则视为小内存,并且设置内存对齐 if (size &lt;= pool-&gt;max) &#123; return ngx_palloc_small(pool, size, 1); &#125;#endif // 否则视为大内存 return ngx_palloc_large(pool, size);&#125; ngx_pnalloc123456789101112// 通过内存池分配内存，不进行内存对齐void *ngx_pnalloc(ngx_pool_t *pool, size_t size)&#123;#if !(NGX_DEBUG_PALLOC) if (size &lt;= pool-&gt;max) &#123; return ngx_palloc_small(pool, size, 0); &#125;#endif return ngx_palloc_large(pool, size);&#125; ngx_pcalloc12345678910111213// 通过内存池进行内存分配，进行内存对齐，并且将内存区域初始化为0void *ngx_pcalloc(ngx_pool_t *pool, size_t size)&#123; void *p; p = ngx_palloc(pool, size); if (p) &#123; ngx_memzero(p, size); &#125; return p;&#125; ngx_pmemalign12345678910111213141516171819202122232425262728// 直接开辟size大小内存，并将该内存块保存在large链上void *ngx_pmemalign(ngx_pool_t *pool, size_t size, size_t alignment)&#123; void *p; ngx_pool_large_t *large; // 开辟 size 大小的内存空间 p = ngx_memalign(alignment, size, pool-&gt;log); if (p == NULL) &#123; return NULL; &#125; // 在小空间池上分配 sizeof(ngx_pool_large_t) 大小的空间，用于保存上面开辟的空间 large = ngx_palloc_small(pool, sizeof(ngx_pool_large_t), 1); if (large == NULL) &#123; ngx_free(p); return NULL; &#125; // 将开辟的空间保存在large链上 large-&gt;alloc = p; large-&gt;next = pool-&gt;large; pool-&gt;large = large; return p;&#125; ngx_palloc_small12345678910111213141516171819202122232425262728293031323334// 分配小块内存static ngx_inline void *ngx_palloc_small(ngx_pool_t *pool, size_t size, ngx_uint_t align)&#123; u_char *m; ngx_pool_t *p; // 获取当前正在使用的内存池 p = pool-&gt;current; do &#123; m = p-&gt;d.last; // 指定了内存对齐的情况下，按照 NGX_ALIGNMENT 对齐，调整待分配的首地址 if (align) &#123; m = ngx_align_ptr(m, NGX_ALIGNMENT); &#125; // 如果剩余空间充足，则调整last指针后，直接返回 m 的地址 if ((size_t) (p-&gt;d.end - m) &gt;= size) &#123; p-&gt;d.last = m + size; return m; &#125; // 当前节点的空间不足，则移动到下一节点继续以上操作 p = p-&gt;d.next; &#125; while (p); // 如果从current节点开始，遍历完所有的节点后，均不能找到合适的内存池进行空间分配， // 则通过以下方法，在操作系统重新开辟一个新的内存池，进行内存分配 return ngx_palloc_block(pool, size);&#125; ngx_palloc_block12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 内存不足时，开辟新的内存池节点static void *ngx_palloc_block(ngx_pool_t *pool, size_t size)&#123; u_char *m; size_t psize; ngx_pool_t *p, *new; psize = (size_t) (pool-&gt;d.end - (u_char *) pool); // 通过malloc开辟psize大小的内存空间， 即传入的pool的内存大小 m = ngx_memalign(NGX_POOL_ALIGNMENT, psize, pool-&gt;log); if (m == NULL) &#123; return NULL; &#125; // 初始化新开辟的pool new = (ngx_pool_t *) m; new-&gt;d.end = m + psize; new-&gt;d.next = NULL; new-&gt;d.failed = 0; m += sizeof(ngx_pool_data_t); // 设置m的地址，按照 NGX_ALIGNMENT 进行地址对齐 // m的地址将作为返回地址，故new-&gt;d.last = m + size，即下一次分配的起始地址 m = ngx_align_ptr(m, NGX_ALIGNMENT); new-&gt;d.last = m + size; // 从current开始，查找 p-&gt;d.next 为NULL的pool节点 for (p = pool-&gt;current; p-&gt;d.next; p = p-&gt;d.next) &#123; // 如果当前pool节点被查找失败的次数超过了4次(小内存分配失败次数超过4次)， // 则直接将current设置为当前节点的next节点 // 此举是为了提升性能，不用每次都从第一个节点遍历到最后一个节点 if (p-&gt;d.failed++ &gt; 4) &#123; pool-&gt;current = p-&gt;d.next; &#125; &#125; // 将新分配的节点添加到next链的尾巴上 p-&gt;d.next = new; return m;&#125; ngx_palloc_large12345678910111213141516171819202122232425262728293031323334353637383940414243// 分配大内存区域static void *ngx_palloc_large(ngx_pool_t *pool, size_t size)&#123; void *p; ngx_uint_t n; ngx_pool_large_t *large; // 通过malloc开辟size大小内存 p = ngx_alloc(size, pool-&gt;log); if (p == NULL) &#123; return NULL; &#125; n = 0; // 将开辟后的内存保存在 pool-&gt;large 链上 for (large = pool-&gt;large; large; large = large-&gt;next) &#123; if (large-&gt;alloc == NULL) &#123; large-&gt;alloc = p; return p; &#125; // TODO: 为啥在链表上查找三个节点，没找到就break了 if (n++ &gt; 3) &#123; break; &#125; &#125; // 在pool上分配一个 ngx_pool_large_t 的内存大小，用于保存开辟的大内存空间 large = ngx_palloc_small(pool, sizeof(ngx_pool_large_t), 1); if (large == NULL) &#123; // 如果分配内存失败，则释放开辟的内存空间 ngx_free(p); return NULL; &#125; large-&gt;alloc = p; large-&gt;next = pool-&gt;large; pool-&gt;large = large; return p;&#125; ngx_pfree123456789101112131415161718192021// 进行内存释放，但是只会释放大内存块ngx_int_tngx_pfree(ngx_pool_t *pool, void *p)&#123; ngx_pool_large_t *l; // 查找待释放的内存地址是否在large链上 for (l = pool-&gt;large; l; l = l-&gt;next) &#123; if (p == l-&gt;alloc) &#123; ngx_log_debug1(NGX_LOG_DEBUG_ALLOC, pool-&gt;log, 0, &quot;free: %p&quot;, l-&gt;alloc); // 找到后，只释放分配出来的内存块，并不会将保存该内存块的链表节点释放掉 ngx_free(l-&gt;alloc); l-&gt;alloc = NULL; return NGX_OK; &#125; &#125; return NGX_DECLINED;&#125; 特殊操作ngx_pool_cleanup_add123456789101112131415161718192021222324252627282930313233343536// 在cleanup 链上添加一个节点并返回ngx_pool_cleanup_t *ngx_pool_cleanup_add(ngx_pool_t *p, size_t size)&#123; ngx_pool_cleanup_t *c; // 在内存池上分配一个 ngx_pool_cleanup_t 结构体 c = ngx_palloc(p, sizeof(ngx_pool_cleanup_t)); if (c == NULL) &#123; return NULL; &#125; // 如果指定的size大小不为0 if (size) &#123; // 通过内存池分配 size 大小的空间 c-&gt;data = ngx_palloc(p, size); if (c-&gt;data == NULL) &#123; return NULL; &#125; &#125; else &#123; // 指定的size大小为0则，将data域设置为NULL c-&gt;data = NULL; &#125; // 将新分配的结构体以前插的方式，放在cleanup链的首端 c-&gt;handler = NULL; c-&gt;next = p-&gt;cleanup; p-&gt;cleanup = c; ngx_log_debug1(NGX_LOG_DEBUG_ALLOC, p-&gt;log, 0, &quot;add cleanup: %p&quot;, c); // 返回分配的cleanup结构体地址 return c;&#125; ngx_pool_run_cleanup_file123456789101112131415161718192021222324// 执行pool中的文件清理工作voidngx_pool_run_cleanup_file(ngx_pool_t *p, ngx_fd_t fd)&#123; ngx_pool_cleanup_t *c; ngx_pool_cleanup_file_t *cf; // 遍历cleanup链 for (c = p-&gt;cleanup; c; c = c-&gt;next) &#123; // 找到出事函数为 ngx_pool_cleanup_file 的节点 if (c-&gt;handler == ngx_pool_cleanup_file) &#123; cf = c-&gt;data; // 如果当前节点的文件描述符是指定的fd if (cf-&gt;fd == fd) &#123; // 执行清理操作 c-&gt;handler(cf); c-&gt;handler = NULL; return; &#125; &#125; &#125;&#125; ngx_pool_cleanup_file1234567891011121314// 文件清理操作处理函数，关闭文件描述符voidngx_pool_cleanup_file(void *data)&#123; ngx_pool_cleanup_file_t *c = data; ngx_log_debug1(NGX_LOG_DEBUG_ALLOC, c-&gt;log, 0, &quot;file cleanup: fd:%d&quot;, c-&gt;fd); if (ngx_close_file(c-&gt;fd) == NGX_FILE_ERROR) &#123; ngx_log_error(NGX_LOG_ALERT, c-&gt;log, ngx_errno, ngx_close_file_n &quot; \\&quot;%s\\&quot; failed&quot;, c-&gt;name); &#125;&#125; ngx_pool_delete_file123456789101112131415161718192021222324252627// 通过内存池的cleanup链删除文件，以及清理文件描述符voidngx_pool_delete_file(void *data)&#123; ngx_pool_cleanup_file_t *c = data; ngx_err_t err; ngx_log_debug2(NGX_LOG_DEBUG_ALLOC, c-&gt;log, 0, &quot;file cleanup: fd:%d %s&quot;, c-&gt;fd, c-&gt;name); // 删除文件 if (ngx_delete_file(c-&gt;name) == NGX_FILE_ERROR) &#123; err = ngx_errno; if (err != NGX_ENOENT) &#123; ngx_log_error(NGX_LOG_CRIT, c-&gt;log, err, ngx_delete_file_n &quot; \\&quot;%s\\&quot; failed&quot;, c-&gt;name); &#125; &#125; // 关闭文件描述符 if (ngx_close_file(c-&gt;fd) == NGX_FILE_ERROR) &#123; ngx_log_error(NGX_LOG_ALERT, c-&gt;log, ngx_errno, ngx_close_file_n &quot; \\&quot;%s\\&quot; failed&quot;, c-&gt;name); &#125;&#125; 参考文献 https://blog.csdn.net/initphp/article/details/50588790st=>start: 开始 io_req_memory=>inputoutput: 请求进行内存分配(ngx_palloc、 ngx_pcalloc、ngx_pcalloc) cond_mem_size=>condition: 请求内存是否超出 节点内存的最大值? sub_small_size=>subroutine: 进行小内存块分配 sub_large_size=>subroutine: 进行大内存块分配 sub1=>subroutine: 子流程 io=>inputoutput: 输入输出 e=>end: 结束 st->io_req_memory->cond_mem_size cond_mem_size(no)->sub_small_size cond_mem_size(yes)->sub_large_size sub_small_size->e sub_large_size->e{\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12} var code = document.getElementById(\"flowchart-0-code\").value; var options = JSON.parse(decodeURIComponent(document.getElementById(\"flowchart-0-options\").value)); var diagram = flowchart.parse(code); diagram.drawSVG(\"flowchart-0\", options);","categories":[{"name":"nginx","slug":"nginx","permalink":"https://blog.wuhui2356.top/categories/nginx/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"https://blog.wuhui2356.top/tags/nginx/"},{"name":"Linux","slug":"linux","permalink":"https://blog.wuhui2356.top/tags/linux/"},{"name":"内存池","slug":"内存池","permalink":"https://blog.wuhui2356.top/tags/%E5%86%85%E5%AD%98%E6%B1%A0/"}]}],"categories":[{"name":"npm","slug":"npm","permalink":"https://blog.wuhui2356.top/categories/npm/"},{"name":"Linux","slug":"linux","permalink":"https://blog.wuhui2356.top/categories/linux/"},{"name":"其他","slug":"其他","permalink":"https://blog.wuhui2356.top/categories/%E5%85%B6%E4%BB%96/"},{"name":"nginx","slug":"nginx","permalink":"https://blog.wuhui2356.top/categories/nginx/"}],"tags":[{"name":"npm","slug":"npm","permalink":"https://blog.wuhui2356.top/tags/npm/"},{"name":"Linux","slug":"linux","permalink":"https://blog.wuhui2356.top/tags/linux/"},{"name":"调试","slug":"调试","permalink":"https://blog.wuhui2356.top/tags/%E8%B0%83%E8%AF%95/"},{"name":"gdb","slug":"gdb","permalink":"https://blog.wuhui2356.top/tags/gdb/"},{"name":"strace","slug":"strace","permalink":"https://blog.wuhui2356.top/tags/strace/"},{"name":"分区","slug":"分区","permalink":"https://blog.wuhui2356.top/tags/%E5%88%86%E5%8C%BA/"},{"name":"parted","slug":"parted","permalink":"https://blog.wuhui2356.top/tags/parted/"},{"name":"逻辑卷","slug":"逻辑卷","permalink":"https://blog.wuhui2356.top/tags/%E9%80%BB%E8%BE%91%E5%8D%B7/"},{"name":"工具","slug":"工具","permalink":"https://blog.wuhui2356.top/tags/%E5%B7%A5%E5%85%B7/"},{"name":"node","slug":"node","permalink":"https://blog.wuhui2356.top/tags/node/"},{"name":"maven","slug":"maven","permalink":"https://blog.wuhui2356.top/tags/maven/"},{"name":"mvn","slug":"mvn","permalink":"https://blog.wuhui2356.top/tags/mvn/"},{"name":"golang","slug":"golang","permalink":"https://blog.wuhui2356.top/tags/golang/"},{"name":"LVM","slug":"lvm","permalink":"https://blog.wuhui2356.top/tags/lvm/"},{"name":"syslog","slug":"syslog","permalink":"https://blog.wuhui2356.top/tags/syslog/"},{"name":"linux","slug":"linux","permalink":"https://blog.wuhui2356.top/tags/linux/"},{"name":"Docker","slug":"docker","permalink":"https://blog.wuhui2356.top/tags/docker/"},{"name":"容器","slug":"容器","permalink":"https://blog.wuhui2356.top/tags/%E5%AE%B9%E5%99%A8/"},{"name":"nginx","slug":"nginx","permalink":"https://blog.wuhui2356.top/tags/nginx/"},{"name":"内存池","slug":"内存池","permalink":"https://blog.wuhui2356.top/tags/%E5%86%85%E5%AD%98%E6%B1%A0/"}]}